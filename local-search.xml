<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一站式讲解本地缓存Caffeine</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E8%AE%B2%E8%A7%A3%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98Caffeine/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E8%AE%B2%E8%A7%A3%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98Caffeine/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上次我们讲了本地缓存guava，那么有没有比它更加优秀的本地缓存呢？有的，兄弟，有的。这次我们来讲本地缓存Caffeine。</p><h1 id="本地缓存的必要性🤤"><a href="#本地缓存的必要性🤤" class="headerlink" title="本地缓存的必要性🤤"></a>本地缓存的必要性🤤</h1><p>不是有了像redis这样的分布式缓存了吗，为什么还要本地缓存呢？因为本地缓存有这样的优势:</p><ol><li><strong>提升性能</strong></li></ol><ul><li><strong>减少延迟</strong>：通过在应用层引入本地缓存作为第一级缓存（L1），可以直接在进程内部快速响应查询请求，而不需要每次都访问更慢的外部存储（如远程缓存或数据库）。这显著减少了响应时间。</li><li><strong>减少IO</strong>：由于本地缓存可以命中部分数据，减少了与分布式缓存的交互，也就减少了IO次数，进而减少了网络开销</li></ul><ol start="2"><li><strong>减轻后端压力</strong></li></ol><ul><li><strong>降低负载</strong>：多级缓存策略可以有效减少对后端数据库或其他外部服务的直接访问次数，从而减轻这些资源的压力，提高整体系统的稳定性和可用性。</li></ul><ol start="3"><li><strong>增加缓存命中率</strong></li></ol><ul><li><strong>优化缓存利用率</strong>：不同的缓存级别可以根据其特点存储不同热度的数据。例如，本地缓存可以存放最常访问的数据，而分布式缓存则用于存放相对较少访问但仍然重要的数据。这种方式能够最大化利用各个层级缓存的优势，提高整体缓存命中率。</li></ul><ol start="4"><li><strong>容错能力增强</strong></li></ol><ul><li><strong>提供冗余</strong>：当一个级别的缓存发生故障或失效时，其他级别的缓存仍然可以提供一定程度的服务，避免了单点失败带来的严重影响，提高了系统的容错能力和可靠性。</li></ul><ol start="5"><li><strong>灵活性与可扩展性</strong></li></ol><ul><li><strong>易于调整和扩展</strong>：根据业务需求的变化，可以灵活地调整各级缓存的大小、过期策略等参数，甚至添加新的缓存层次，以适应不断变化的工作负载。</li></ul><h1 id="多级缓存访问流程🥹"><a href="#多级缓存访问流程🥹" class="headerlink" title="多级缓存访问流程🥹"></a>多级缓存访问流程🥹</h1><p>在<strong>多级缓存架构</strong>中，一般的设计模式是：</p><blockquote><p><strong>先查本地缓存（L1缓存） → 未命中则查分布式缓存（L2缓存） → 还未命中才查询数据库。</strong></p></blockquote><p>这种设计的目的在于<strong>兼顾性能与一致性</strong></p><p><img src="https://i-blog.csdnimg.cn/direct/5c84a039bc0a4a94963f0efc739c633b.png" alt="在这里插入图片描述"></p><h1 id="使用Caffeine作为本地缓存😶‍🌫️"><a href="#使用Caffeine作为本地缓存😶‍🌫️" class="headerlink" title="使用Caffeine作为本地缓存😶‍🌫️"></a>使用Caffeine作为本地缓存😶‍🌫️</h1><p>首先要注意的是，Caffeine本身并不提供注解来使用缓存功能。Caffeine 提供了 <code>newBuilder()</code> API 来以编程方式配置和使用缓存。</p><p>所以我们这里可以使用<strong>Spring Cache 集成 Caffeine</strong>的方式来使用Caffeine的本地缓存功能，这样非常方便，因为它允许通过注解来（如 <code>@Cacheable</code>、<code>@CachePut</code> 和 <code>@CacheEvict</code>）来声明性地配置缓存</p><h2 id="添加Spring-Cache-和-Guava-依赖"><a href="#添加Spring-Cache-和-Guava-依赖" class="headerlink" title="添加Spring Cache 和 Guava 依赖"></a>添加<strong>Spring Cache 和 Guava 依赖</strong></h2><p>在pom文件添加以下依赖：确保版本号与你的项目兼容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置-Caffeine-缓存"><a href="#配置-Caffeine-缓存" class="headerlink" title="配置 Caffeine 缓存"></a>配置 Caffeine 缓存</h2><p>和guava不同的是，guava需要配置类才可以使用注解开发，而caffeine由于和Spring高度结合，直接在yml文件进行配置即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">caffeine</span><br>    <span class="hljs-attr">caffeine:</span><br>      <span class="hljs-attr">spec:</span> <span class="hljs-string">maximumSize=500,expireAfterAccess=60s</span><br></code></pre></td></tr></table></figure><p>当然，你想使用配置类来实现更细粒度的控制或者有多个缓存管理器时，可以通过创建一个配置类来指定缓存管理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CaffeineCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CaffeineCacheManager</span>();<br>        cacheManager.setCaffeine(caffeineCacheBuilder());<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br><br>    Caffeine&lt;Object, Object&gt; <span class="hljs-title function_">caffeineCacheBuilder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Caffeine.newBuilder()<br>                .expireAfterWrite(<span class="hljs-number">60</span>, TimeUnit.SECONDS)<br>                .maximumSize(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个配置类中：</p><ul><li>使用了 <code>@EnableCaching</code> 注解启用缓存。</li><li>定义了一个 <code>cacheManager()</code> 方法返回一个 <code>CaffeineCacheManager</code> 实例，并设置了 Caffeine 缓存构建器。</li><li>在 <code>caffeineCacheBuilder()</code> 方法中，配置了缓存的有效期和最大容量等参数。</li></ul><p>这种方式提供了更大的灵活性，允许你根据应用的需求定制缓存的行为。</p><h2 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h2><p>如果你没有进行创建配置类，就需要在你的主应用程序类或配置类上添加 <code>@EnableCaching</code> 注解以启用缓存功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YourApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(YourApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用缓存注解"><a href="#使用缓存注解" class="headerlink" title="使用缓存注解"></a>使用缓存注解</h2><p>现在你可以在你的服务层方法上使用 Spring 的缓存注解，比如 <code>@Cacheable</code>, <code>@CachePut</code>, 和 <code>@CacheEvict</code> 等等，以便根据需要控制缓存的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YourService</span> &#123;<br><br>    <span class="hljs-meta">@Cacheable(&quot;books&quot;)</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">findBook</span><span class="hljs-params">(ISBN isbn)</span> &#123;<br>        <span class="hljs-comment">// 方法逻辑...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要看详细的Spring缓存注解介绍，可以看我的关于guava本地缓存的介绍，因为已经讲过，这里就不再重复。</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>后台缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>后台缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官拷打我线程池，我这样回答....</title>
    <link href="/2025/06/22/%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8B%B7%E6%89%93%E6%88%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E6%88%91%E8%BF%99%E6%A0%B7%E5%9B%9E%E7%AD%94/"/>
    <url>/2025/06/22/%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8B%B7%E6%89%93%E6%88%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E6%88%91%E8%BF%99%E6%A0%B7%E5%9B%9E%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>如果大家在简历中写熟悉Java并发编程或者项目有牵扯到线程池相关内容，那么被拷打线程池是大概率的事。下面的内容是有关今年五月份某大厂面试中有关线程池的拷打，我从中提取一些比较通用的内容进行解答，让我们一起看看吧！</p><h1 id="线程池的好处😯"><a href="#线程池的好处😯" class="headerlink" title="线程池的好处😯"></a>线程池的好处😯</h1><p>经典起手，这就非常八股了，这里我想让大家都明白一个道理，生活和学习中，都要先明白做这件事的好处（坏处）是什么，再想如何做可能灵感就会多得多，好的下面让我们回归正题❤️。</p><p>在Java开发中，使用线程池（如通过<code>ThreadPoolExecutor</code>类实现）有多个好处：</p><ol><li><strong>重用线程</strong>：通过线程池可以重用已创建的线程。如果不使用线程池，每次需要执行一个任务时都必须创建一个新的线程，在任务完成后销毁该线程。这种做法会导致大量的资源消耗和性能损耗。而线程池允许线程被重复利用，减少了线程创建和销毁的开销。</li><li><strong>控制并发线程数量</strong>：线程池可以帮助你限制系统中并发执行的线程数量。通过设定最大线程数，你可以避免因为过多的线程同时运行而导致系统过载的问题。</li><li><strong>管理队列</strong>：当所有线程都在忙碌时，新的任务会被放入等待队列中，直到有可用的线程来处理它们。这有助于平滑负载峰值。</li><li><strong>提高响应速度</strong>：由于线程已经被创建并就绪，因此当有新任务到达时可以立即开始执行，不需要经历线程创建的延迟，从而提高了应用对请求的响应速度。</li><li><strong>方便的管理功能</strong>：<code>ThreadPoolExecutor</code>提供了多种管理和监控线程池的方法，比如获取当前活跃线程数、关闭线程池等。</li><li><strong>调度能力</strong>：结合<code>ScheduledThreadPoolExecutor</code>，还可以实现定时或周期性的任务执行。</li></ol><p><code>ThreadPoolExecutor</code>是Java提供的一个灵活的线程池实现，它允许开发者根据具体需求配置核心线程数、最大线程数、空闲线程存活时间、工作队列类型等参数。这些特性使得它成为处理大量异步任务执行的理想选择。</p><h1 id="怎么创建一个线程池🤗"><a href="#怎么创建一个线程池🤗" class="headerlink" title="怎么创建一个线程池🤗"></a>怎么创建一个线程池🤗</h1><p>在Java中创建一个线程池可以通过<code>java.util.concurrent.Executors</code>工厂类或者直接实例化<code>ThreadPoolExecutor</code>来实现。下面是两种不同的方法：</p><h2 id="使用Executors工厂类"><a href="#使用Executors工厂类" class="headerlink" title="使用Executors工厂类"></a>使用Executors工厂类</h2><p><code>Executors</code>提供了一系列静态工厂方法来创建不同类型的线程池，这些方法包括但不限于：</p><ul><li><p><strong>固定大小的线程池</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>这个方法会创建一个拥有10个线程的线程池，如果所有线程都在忙，额外的任务将会在队列中等待。</p></li><li><p><strong>缓存型线程池</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的应用程序来说，这类线程池是理想选择。</p></li><li><p><strong>单线程化的线程池</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br></code></pre></td></tr></table></figure><p>创建一个只有一个工作线程的线程池，以无顺序的方式一个接一个地执行任务。</p></li><li><p><strong>调度线程池</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>创建一个支持定时和周期性任务执行的线程池，具有指定的核心线程数。</p></li></ul><h2 id="直接使用ThreadPoolExecutor"><a href="#直接使用ThreadPoolExecutor" class="headerlink" title="直接使用ThreadPoolExecutor"></a>直接使用ThreadPoolExecutor</h2><p>如果你想更细致地控制线程池的行为，可以直接使用<code>ThreadPoolExecutor</code>的构造函数，它提供了最大的灵活性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-number">20</span>, <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-number">1</span>, TimeUnit.MINUTES, <span class="hljs-comment">// 线程空闲时间</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">100</span>), <span class="hljs-comment">// 工作队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="hljs-comment">// 拒绝策略</span><br></code></pre></td></tr></table></figure><p>这里，</p><ul><li>核心线程数是指线程池中的常驻线程数。</li><li>最大线程数是指线程池中允许存在的最大线程数。</li><li>线程空闲时间是指超过核心线程数的那些线程，在空闲了指定的时间后会被终止。</li><li>工作队列用于保存等待执行的任务。</li><li>拒绝策略定义了当任务无法被提交到线程池时的行为。</li></ul><p>创建好线程池之后，你可以通过调用<code>execute()</code>或<code>submit()</code>方法来向线程池提交任务。记得在线程池不再使用时调用<code>shutdown()</code>方法来关闭线程池，确保程序可以正常退出。</p><h1 id="线程池拒绝策略🤓"><a href="#线程池拒绝策略🤓" class="headerlink" title="线程池拒绝策略🤓"></a>线程池拒绝策略🤓</h1><p>在Java中，当线程池无法接受新任务时（例如，当所有线程都在忙碌且工作队列已满），需要一种策略来处理这种情况。这种策略被称为线程池的拒绝策略，它由<code>RejectedExecutionHandler</code>接口定义，并且Java提供了几种内置的实现：</p><ol><li><p><strong>AbortPolicy（默认策略）</strong> ：</p><ul><li>抛出一个<code>RejectedExecutionException</code>异常。这可以让你捕获异常并进行相应的处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor.AbortPolicy()<br></code></pre></td></tr></table></figure></li><li><p><strong>CallerRunsPolicy</strong>：</p><ul><li>不在线程池中的线程执行任务，而是直接在调用者线程中运行被拒绝的任务。这种方式提供了一种简单的反馈控制机制，减缓了新任务的提交速度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor.CallerRunsPolicy()<br></code></pre></td></tr></table></figure></li><li><p><strong>DiscardPolicy</strong>：</p><ul><li>直接丢弃被拒绝的任务，不做任何处理也不会抛出异常。这种策略适用于当你不需要关心任务丢失的情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor.DiscardPolicy()<br></code></pre></td></tr></table></figure></li><li><p><strong>DiscardOldestPolicy</strong>：</p><ul><li>如果线程池没有关闭，则将工作队列中的第一个任务（即最旧的那个未处理的任务）丢弃，然后尝试重新提交被拒绝的任务。注意，这个策略不会保证任务的顺序执行，因为它可能导致较早提交的任务被后来的任务取代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadPoolExecutor.DiscardOldestPolicy()<br></code></pre></td></tr></table></figure></li></ol><p>你可以通过以下方式为<code>ThreadPoolExecutor</code>设置自定义的拒绝策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    corePoolSize, <br>    maximumPoolSize, <br>    keepAliveTime, <br>    TimeUnit.MILLISECONDS, <br>    workQueue, <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy());<br></code></pre></td></tr></table></figure><p>其中，<code>new ThreadPoolExecutor.DiscardPolicy()</code>可以替换为你选择的任何一种拒绝策略。这样做可以帮助你更好地管理线程池的行为，尤其是在高负载的情况下。</p><h1 id="预热线程池🤠"><a href="#预热线程池🤠" class="headerlink" title="预热线程池🤠"></a>预热线程池🤠</h1><p>熟悉线程池任务执行流程的都清楚，线程池刚创建时，里面并没有核心线程数的，是一个任务来，才创建一个核心线程，直到到核心线程数。</p><p>在Java中，<code>ThreadPoolExecutor</code>允许你通过预先启动核心线程数来“预热”线程池。这意味着即使没有任务提交到线程池，核心线程也会被创建并保持活动状态，准备立即处理任务。这样做可以减少首次执行任务时的延迟，因为不需要等待线程的创建过程。</p><p>要实现这一点，你可以使用<code>prestartCoreThread()</code>或<code>prestartAllCoreThreads()</code>方法：</p><ul><li><strong><code>prestartCoreThread()</code></strong> ：尝试启动一个尚未启动的核心线程。如果当前已经有等于核心线程数量的线程处于活动状态，则此方法将不起作用。它返回一个布尔值，指示是否成功启动了一个新的线程。</li><li><strong><code>prestartAllCoreThreads()</code></strong> ：启动所有核心线程，即根据设定的核心线程数一次性启动对应数量的线程。此方法会返回实际启动的线程数。</li></ul><p>下面是一个简单的例子，演示如何使用这些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolPreheatExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;<br><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                corePoolSize,<br>                maximumPoolSize,<br>                keepAliveTime,<br>                TimeUnit.MILLISECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br><br>        <span class="hljs-comment">// 预先启动所有核心线程</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prestartedThreads</span> <span class="hljs-operator">=</span> executor.prestartAllCoreThreads();<br>        System.out.println(<span class="hljs-string">&quot;预先启动的核心线程数: &quot;</span> + prestartedThreads);<br><br>        <span class="hljs-comment">// 提交一些任务给线程池</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在执行任务&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 模拟任务执行时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池（在实际应用中，请确保所有任务已完成）</span><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个具有5个核心线程和最多10个线程的线程池，并调用<code>prestartAllCoreThreads()</code>方法来预热线程池，确保所有核心线程都已准备好处理任务。这样，当任务开始提交到线程池时，它们可以立即由已经活跃的核心线程处理，无需等待线程的初始化过程。</p><h1 id="给线程池中的线程指定名字🤩"><a href="#给线程池中的线程指定名字🤩" class="headerlink" title="给线程池中的线程指定名字🤩"></a>给线程池中的线程指定名字🤩</h1><p>在 Java 中，默认情况下，线程池中创建的线程名称是由 JVM 自动生成的（如 <code>pool-1-thread-1</code>），但为了方便调试和日志追踪，我们通常希望自定义这些线程的名字。</p><h2 id="给线程池中的线程指定名字的方法："><a href="#给线程池中的线程指定名字的方法：" class="headerlink" title="给线程池中的线程指定名字的方法："></a>给线程池中的线程指定名字的方法：</h2><p>你需要通过实现 <code>ThreadFactory</code> 接口，并传入到线程池中。Java 提供了 <code>java.util.concurrent.ThreadFactory</code> 接口，你可以自定义线程工厂来设置线程名称。</p><hr><p><strong>示例：使用自定义 ThreadFactory 设置线程名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NamedThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br>        <br>        <span class="hljs-comment">// 自定义线程工厂</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">namedThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;MyCustomThread-&quot;</span> + threadId++);<br>                <span class="hljs-comment">// 可以设置为守护线程或设置优先级等</span><br>                <span class="hljs-comment">// t.setDaemon(true);</span><br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 创建线程池</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                corePoolSize,<br>                maxPoolSize,<br>                keepAliveTime,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),<br>                namedThreadFactory<br>        );<br><br>        <span class="hljs-comment">// 提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskNo</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在执行任务 &quot;</span> + taskNo);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>输出示例（线程名自定义）：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">深色版本<br>MyCustomTh<span class="hljs-built_in">read-1</span> 正在执行任务 <span class="hljs-number">0</span><br>MyCustomTh<span class="hljs-built_in">read-2</span> 正在执行任务 <span class="hljs-number">1</span><br>MyCustomTh<span class="hljs-built_in">read-3</span> 正在执行任务 <span class="hljs-number">2</span><br>MyCustomTh<span class="hljs-built_in">read-1</span> 正在执行任务 <span class="hljs-number">3</span><br>MyCustomTh<span class="hljs-built_in">read-2</span> 正在执行任务 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><hr><h2 id="使用-Executors-defaultThreadFactory-的变种（可选）"><a href="#使用-Executors-defaultThreadFactory-的变种（可选）" class="headerlink" title="使用 Executors.defaultThreadFactory() 的变种（可选）"></a>使用 <code>Executors.defaultThreadFactory()</code> 的变种（可选）</h2><p>你也可以基于默认的 <code>ThreadFactory</code> 进行包装，比如 Apache Commons 或 Google Guava 提供的工具类（如 <code>ThreadFactoryBuilder</code>），可以更简洁地命名线程。</p><p>例如使用 <strong>Guava</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;<br><br><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>        .setNameFormat(<span class="hljs-string">&quot;my-pool-%d&quot;</span>)<br>        .setDaemon(<span class="hljs-literal">true</span>)<br>        .build();<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>, factory);<br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>方法</th><th>是否推荐</th><th>说明</th></tr></thead><tbody><tr><td>实现 <code>ThreadFactory</code> 接口</td><td>推荐</td><td>灵活、可控，适合生产环境</td></tr><tr><td>使用 Guava 的 <code>ThreadFactoryBuilder</code></td><td>推荐</td><td>更加简洁，依赖第三方库</td></tr><tr><td>默认线程工厂</td><td>不推荐</td><td>名称不直观，不利于排查问题</td></tr></tbody></table><h1 id="在平时工作中怎么来制定你的核心线程数和最大线程数😶‍🌫️"><a href="#在平时工作中怎么来制定你的核心线程数和最大线程数😶‍🌫️" class="headerlink" title="在平时工作中怎么来制定你的核心线程数和最大线程数😶‍🌫️"></a>在平时工作中怎么来制定你的核心线程数和最大线程数😶‍🌫️</h1><p>在实际工作中，合理设置线程池的 <strong>核心线程数（corePoolSize）</strong> 和 <strong>最大线程数（maximumPoolSize）</strong> 是非常关键的。设置不合理会导致资源浪费、系统响应变慢甚至崩溃。下面是一些常见的思路和方法。</p><p><strong>1.根据任务类型选择策略</strong></p><ol><li><strong>CPU密集型任务</strong></li></ol><ul><li><p>特点：主要消耗CPU资源，如计算、加密、压缩等。</p></li><li><p>建议：</p><ul><li>核心线程数 ≈ CPU核数</li><li>最大线程数 ≈ CPU核数 × 2（视情况）</li><li>不需要太多线程，避免上下文切换开销过大</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>IO密集型任务</strong></li></ol><ul><li><p>特点：大量等待IO完成（如网络请求、数据库查询、磁盘读写）</p></li><li><p>建议：</p><ul><li>可以适当增加线程数，因为很多线程处于等待状态</li><li>核心线程数 &#x3D; CPU核数 × 2 或更高</li><li>最大线程数可设为更高的值（如 50~200）</li></ul></li></ul><p><strong>2.结合任务队列分析负载</strong></p><ul><li>如果任务队列经常积压 → 增加核心线程数或最大线程数</li><li>如果线程池频繁扩容 → 可能是 corePoolSize 设置太小</li><li>如果 keepAliveTime 太短，非核心线程刚启动就销毁了 → 浪费资源</li></ul><p><strong>3.监控线程池</strong><br>建议在线上部署时，配合以下手段：</p><ul><li><p>使用 <code>ThreadPoolTaskExecutor</code>（Spring中常用）并暴露指标</p></li><li><p>结合 Prometheus + Grafana 监控：</p><ul><li>活跃线程数</li><li>队列大小</li><li>拒绝任务数</li></ul></li><li><p>动态调整线程池参数（动态线程池）</p></li></ul><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>对Java线程池的理解和使用，是每位Java程序员的必备技能。</p><p>这是后端面试常问的问题，建议各位结合自己的项目进行回答，面试官问你的优化方法也可以有更多的思路。如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Java并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>想为Seata社区进行贡献？这几点你需要了解</title>
    <link href="/2025/06/22/%E6%83%B3%E4%B8%BASeata%E7%A4%BE%E5%8C%BA%E8%BF%9B%E8%A1%8C%E8%B4%A1%E7%8C%AE%EF%BC%9F%E8%BF%99%E5%87%A0%E7%82%B9%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3/"/>
    <url>/2025/06/22/%E6%83%B3%E4%B8%BASeata%E7%A4%BE%E5%8C%BA%E8%BF%9B%E8%A1%8C%E8%B4%A1%E7%8C%AE%EF%BC%9F%E8%BF%99%E5%87%A0%E7%82%B9%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>很多新人朋友都想在Github上为开源社区进行贡献（包括我），而其中seata社区是活跃度相对较高的社区之一，但是一头扎进去容易一脸懵，如果你也想为seata贡献你的代码，你可以看看我以下提到的几点，兴许你会用到🤓</p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>你先需要将seata库fork下来，然后你才可以提交代码到自己的fork库，然后进行clone，将最新代码拉取到自己的idea。</p><p>然后需要设置远程，方便更新代码工作区， <strong>设置远程</strong> 将上游设置为 <code>git@github.com:apache/incubator-seata.git</code> 使用以下两个命令：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-string">add</span> <span class="hljs-string">upstream</span> <span class="hljs-string">git</span>@<span class="hljs-string">github</span>.<span class="hljs-string">com:apache/</span><span class="hljs-string">incubator-seata</span>.<span class="hljs-string">git</span><br><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-built_in">--push</span> <span class="hljs-string">upstream</span> <span class="hljs-string">no-pushing</span><br></code></pre></td></tr></table></figure><h1 id="踩坑一😶‍🌫️"><a href="#踩坑一😶‍🌫️" class="headerlink" title="踩坑一😶‍🌫️"></a>踩坑一😶‍🌫️</h1><p>当你将源码拉下来之后，发现启动不了，第一个问题就是版本不对，截止发文日期，你能从源码拉下来的版本是2.5.0的快照版本，这样出现依赖找不到的问题</p><p><img src="https://i-blog.csdnimg.cn/direct/a76fe7dbc27d41b38d1548675fd74f6c.png" alt="在这里插入图片描述"></p><p>为了解决这个问题，你需要在seata-build模块下更改pom文件，上一图的版本改成2.3.0即可</p><p><img src="https://i-blog.csdnimg.cn/direct/b95cb557e8454f5490bcc2b8f14c3630.png" alt="在这里插入图片描述"></p><h1 id="踩坑二😭"><a href="#踩坑二😭" class="headerlink" title="踩坑二😭"></a>踩坑二😭</h1><p>当你以为终于可以启动的时候，现实会给你一棒…</p><p>这个VersionInfo会找不到类<br><img src="https://i-blog.csdnimg.cn/direct/ceab2837e1e64135ad0800e3874552b9.png" alt="在这里插入图片描述"></p><p>为了解决这个问题，开启全局搜索，你可以找到seata-core模块，在org.apache.seata.core.protocol包下，你可以找到VersionInfo.java.template这个文件，你要相信任何东西不是无缘无故的就会出现在这的，将其复制一份，改成VersionInfo.java，放在同位置即可</p><p><img src="https://i-blog.csdnimg.cn/direct/c23188597fd0409dad67fbab2bd1dfb8.png" alt="在这里插入图片描述"></p><h1 id="踩坑三😵"><a href="#踩坑三😵" class="headerlink" title="踩坑三😵"></a>踩坑三😵</h1><p><strong><code>org.apache.seata.core.protocol.generated</code> 包不存在</strong></p><p>当你再次启动，会发现找不到这个程序包，这个是因为Grpc，需要插件编译proto文件成java文件才可以找到，点击下面那个编译即可</p><p><img src="https://i-blog.csdnimg.cn/direct/65c77174f40c4c699322627677a121a0.png" alt="在这里插入图片描述"></p><p>然后将生成类的java目录右键成源码目录即可</p><p><img src="https://i-blog.csdnimg.cn/direct/b02bf02762a4487e8acb2eeb1ba1e547.png" alt="在这里插入图片描述"></p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这就是一些进行seata开源时会踩到的一些坑，希望对你有所帮助。</p><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>Seata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Seata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试回答喜欢用构造器注入，面试官很满意...</title>
    <link href="/2025/06/22/%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E5%96%9C%E6%AC%A2%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BE%88%E6%BB%A1%E6%84%8F/"/>
    <url>/2025/06/22/%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E5%96%9C%E6%AC%A2%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BE%88%E6%BB%A1%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>大家在SpringBoot项目开发中进行依赖注入时，是不是都喜欢用字段注入呢？即使用<code>@Autowired</code>，<code>@Resource</code>。没错，这种方式最简单与简洁，但是为什么在面试中，面试官问起你有关依赖注入的问题时，最好不要回答用字段注入呢？而是回答用构造器注入，接下来让我们一起来探讨一下常见的三种依赖注入方式。</p><h1 id="字段注入-Field-Injection-😵"><a href="#字段注入-Field-Injection-😵" class="headerlink" title="字段注入(Field Injection)😵"></a>字段注入(Field Injection)😵</h1><p>字段注入（Field Injection）是Spring框架中依赖注入的一种方式，它允许开发者直接在类的字段上使用<code>@Autowired</code>或者<code>@Resource</code>注解来自动装配依赖。</p><p>下面通过一个简单例子来示例怎么使用字段注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dependency dependency;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAction</span><span class="hljs-params">()</span> &#123;<br>        dependency.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当这个类上面加了注解@Service，Spring就会将其当成一个Bean实例化到容器中方便取用，这样就可以避免多次创建或者销毁同一个类对象，方便复用，提高资源利用率。在这个例子中，<code>MyService</code> 类有一个 <code>Dependency</code> 类型的依赖，通过在字段上添加 <code>@Autowired</code> 注解，Spring 会自动在容器中寻找Bean，将合适的 <code>Dependency</code> Bean 注入到这个字段中。</p><p><strong><code>@Autowired</code>和<code>@Resource</code>的区别</strong></p><p>简单来说，<code>@Autowired</code>默认时通过类型匹配来进行依赖注入，而<code>@Resource</code>默认是通过基于名称来进行注入（是指bean在容器里面的名称🥹），所以你在使用<code>@Resource</code>时，最好清楚指定bean在容器中的名称哦。</p><ol><li><code>@Resource</code> 只能用于字段或 setter 方法上，不能用在构造器上。</li><li>如果你没有指定 <code>name</code> 属性，Spring 会尝试使用字段名或 setter 方法的属性名作为 Bean 名称进行匹配。</li><li>当找不到名称匹配的 Bean 时，<code>@Resource</code> <strong>不会回退到按类型匹配</strong></li></ol><h1 id="设值方法注入-Setter-Injection-🤤"><a href="#设值方法注入-Setter-Injection-🤤" class="headerlink" title="设值方法注入 (Setter Injection)🤤"></a>设值方法注入 (Setter Injection)🤤</h1><p>Setter注入通过类的setter方法来为类提供所需的依赖。这种方式与构造器注入相比，具有一定的灵活性，特别适合于那些依赖项可选或者希望在对象创建之后能够<strong>修改依赖</strong>的情况。</p><p><strong>Tips：</strong> Setter注入通常遵循JavaBean规范，以<code>set</code>开头，后跟属性名，并且只有一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Dependency dependency;<br><br>    <span class="hljs-comment">// Setter注入</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDependency</span><span class="hljs-params">(Dependency dependency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAction</span><span class="hljs-params">()</span> &#123;<br>        dependency.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyService</code> 类有一个 <code>Dependency</code> 类型的依赖，通过带有 <code>@Autowired</code> 注解的 setter 方法 <code>setDependency</code> 来注入这个依赖</p><ol><li><strong>灵活性</strong>：允许在对象创建之后更改依赖关系，这对于一些需要动态改变依赖的情况非常有用。</li><li><strong>可选依赖</strong>：如果某个依赖不是必须的，那么你可以不使用 <code>@Autowired</code> 注解，而是直接定义一个普通的 setter 方法，这样即使没有配置相应的 Bean，应用也不会出错</li></ol><p><strong>请注意：</strong> 即使Spring支持setter注入可以帮助解决某些类型的循环依赖问题，但应尽量避免设计上出现循环依赖的情况😵</p><h1 id="构造器注入-Constructor-Injection-🤩"><a href="#构造器注入-Constructor-Injection-🤩" class="headerlink" title="构造器注入 (Constructor Injection)🤩"></a>构造器注入 (Constructor Injection)🤩</h1><p><strong>构造器注入</strong> 是 Spring 中最推荐的依赖注入方式之一。它通过类的构造函数（构造器）来注入依赖对象。Spring 容器在创建 Bean 实例时，会自动调用合适的构造器，并将所需的依赖作为参数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Dependency dependency;<br><br>    <span class="hljs-comment">// 构造器注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(Dependency dependency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAction</span><span class="hljs-params">()</span> &#123;<br>        dependency.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MyService</code> 类需要一个 <code>Dependency</code> 类型的依赖，使用构造器注入后，该依赖在对象初始化时就被设置好了，但请注意：从 <strong>Spring 4.3 及以上版本</strong> 开始，如果类只有一个构造器，<strong>可以省略 <code>@Autowired</code> 注解</strong>，Spring 会自动识别并使用该构造器注入依赖。</p><h1 id="为什么说构造器注入是最推荐的一种依赖注入方式🤓"><a href="#为什么说构造器注入是最推荐的一种依赖注入方式🤓" class="headerlink" title="为什么说构造器注入是最推荐的一种依赖注入方式🤓"></a>为什么说构造器注入是最推荐的一种依赖注入方式🤓</h1><h2 id="保证不可变性"><a href="#保证不可变性" class="headerlink" title="保证不可变性"></a>保证不可变性</h2><p>使用构造器注入，可以将依赖项声明为<code>final</code>字段。这意味着一旦对象被创建后，它的依赖就不会再改变。这种不变性有助于确保对象在其生命周期内的状态一致性，从而减少潜在的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Dependency dependency;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(Dependency dependency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dependency = dependency;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>dependency</code> 字段是 <code>final</code> 的，意味着它在对象被创建之后不能被修改。这增强了代码的安全性和可维护性。这在实战中一般通过使用 <code>final</code> 关键字定义依赖，防止它们在对象创建之后被修改。</p><h2 id="保证依赖完整性"><a href="#保证依赖完整性" class="headerlink" title="保证依赖完整性"></a>保证依赖完整性</h2><p>所有必须的依赖都在构造器中声明，保证了类在使用前就具备所有必需的依赖。这样错误就可以在编译阶段就可以检测出来，防止应用在运行时出现错误，也就避免了因依赖未注入而导致的 <code>NullPointerException</code> 等运行时错误。</p><h2 id="易于单元测试"><a href="#易于单元测试" class="headerlink" title="易于单元测试"></a>易于单元测试</h2><p>由于依赖是通过构造器传入的，你可以在测试中轻松地传入模拟对象（mock），而不需要依赖 Spring 容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMyService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Dependency</span> <span class="hljs-variable">mockDependency</span> <span class="hljs-operator">=</span> Mockito.mock(Dependency.class);<br>    <span class="hljs-type">MyService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyService</span>(mockDependency); <span class="hljs-comment">// 手动注入</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="明确API设计"><a href="#明确API设计" class="headerlink" title="明确API设计"></a>明确API设计</h2><p>构造器清楚地表明了一个类所依赖的对象，提高了代码的可读性和可维护性。（这对于团队协作是非常重要的，你也不想被其他好厚米暴打吧🤣）</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>虽然说构造器注入十分推荐使用，但还是要具体情况具体实践，因为构造器注入也有其不足之处，比如要可选依赖时，这种情况更适合使用 setter 注入。如果依赖过多，构造器参数列表会变得冗长，影响可读性等问题，也可以尝试用字段注入或者Builder模式优化。总之一句话，具体情况具体实践！</p><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官问我：库存预扣减之后，用户订单超时之后怎么补偿库存？我的方案让他满意...</title>
    <link href="/2025/06/22/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%EF%BC%9A%E5%BA%93%E5%AD%98%E9%A2%84%E6%89%A3%E5%87%8F%E4%B9%8B%E5%90%8E%EF%BC%8C%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E8%A1%A5%E5%81%BF%E5%BA%93%E5%AD%98%EF%BC%9F%E6%88%91%E7%9A%84%E6%96%B9%E6%A1%88%E8%AE%A9%E4%BB%96%E6%BB%A1%E6%84%8F/"/>
    <url>/2025/06/22/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%EF%BC%9A%E5%BA%93%E5%AD%98%E9%A2%84%E6%89%A3%E5%87%8F%E4%B9%8B%E5%90%8E%EF%BC%8C%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E8%A1%A5%E5%81%BF%E5%BA%93%E5%AD%98%EF%BC%9F%E6%88%91%E7%9A%84%E6%96%B9%E6%A1%88%E8%AE%A9%E4%BB%96%E6%BB%A1%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在后端开发和面试中，如果是做类似秒杀和商城等业务时，我们难免会遇到关于订单超时了，但是Redis里面的库存已经预扣减了，那么如何把预扣减的库存进行补偿呢？下面和大家讨论几种比较常见常用的方案。</p><h1 id="为什么要补偿预扣减的库存？😵"><a href="#为什么要补偿预扣减的库存？😵" class="headerlink" title="为什么要补偿预扣减的库存？😵"></a>为什么要补偿预扣减的库存？😵</h1><p>古人常说，要做一件事之前，先要清楚为什么要做这件事，再去想解决这件事的方案。我认为这种说法也是对的，只有先清楚为什么要补偿预扣减的库存，才能获得解决方案的灵感。</p><p>在一个秒杀业务中，大家一起来抢购这种商品，但是商品数额有限。一位用户率先抢到这个商品，已经成功下单（即已经有了订单号），但是尚未结款，也就代表数据库还没有真正落库扣减这个商品，只是在Redis进行预扣减了这件库存。该用户在后来的一段时间因为某事忘记了付款，即订单超时，那么我们就要把这个Redis中预扣减的库存补偿回Redis中，否则就会造成后来的用户无法继续抢购，也就是少卖现象，会给商家利益造成损失。</p><h1 id="方案一：Redis的过期监听🤤"><a href="#方案一：Redis的过期监听🤤" class="headerlink" title="方案一：Redis的过期监听🤤"></a>方案一：Redis的过期监听🤤</h1><p>在redis里面中，key可以设过期时间，这就给我们提供了一个思路：我们可以给预扣减的库存键设一个过期时间，使用redis的发布订阅机制来监听键过期事件，从而自动触发回增库存的逻辑</p><p> 功能目标：</p><ul><li>监听 Redis 中所有以 <code>product:</code> 开头的商品 key 的过期事件。</li><li>一旦某个商品 key 过期（比如用户超时未支付），自动执行库存回补（<code>INCR</code>）操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonStockExpiredListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-comment">// 模拟预扣减库存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">productKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;product:1001:stock&quot;</span>;<br>        <span class="hljs-type">RBatch</span> <span class="hljs-variable">batch</span> <span class="hljs-operator">=</span> redisson.getBatch();<br>        batch.get(productKey).setAsync(<span class="hljs-number">100L</span>);           <span class="hljs-comment">// 初始化库存</span><br>        batch.get(productKey).decrementAsync();         <span class="hljs-comment">// 预扣减</span><br>        batch.get(productKey).expireAsync(<span class="hljs-number">5</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 设置5秒过期</span><br>        batch.execute();<br><br>        System.out.println(<span class="hljs-string">&quot;已预扣减库存，并设置5秒后过期&quot;</span>);<br><br>        <span class="hljs-comment">// 订阅 Redis 的 key 过期事件</span><br>        <span class="hljs-type">RTopic</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> redisson.getTopic(<span class="hljs-string">&quot;__keyevent@*:expired&quot;</span>);<br>        topic.addListener(String.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListener</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(CharSequence channel, String key)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;监听到 key 过期：&quot;</span> + key);<br><br>                <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; key.startsWith(<span class="hljs-string">&quot;product:&quot;</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;处理商品 key 过期，准备补偿库存...&quot;</span>);<br><br>                    <span class="hljs-comment">// 补偿库存：INCR</span><br>                    <span class="hljs-type">RAtomicLong</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisson.getAtomicLong(key);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">newStock</span> <span class="hljs-operator">=</span> stock.incrementAndGet(); <span class="hljs-comment">// INCR</span><br>                    System.out.println(<span class="hljs-string">&quot;库存已补偿，当前库存：&quot;</span> + newStock);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;忽略非商品 key：&quot;</span> + key);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;正在监听 Redis key 过期事件...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方案的优点是实时性强，对要求实时性高的业务比较友好，如抢票等。缺点是过于依靠Redis，风险不能分摊。且容易造成大量过期Key问题，影响性能。</p><h1 id="方案二：Redis的延时队列😉"><a href="#方案二：Redis的延时队列😉" class="headerlink" title="方案二：Redis的延时队列😉"></a>方案二：Redis的延时队列😉</h1><p>我们可以基于Redis的Sorted Set数据类型来做一个延时队列，通过score来进行排序，我们服务端下单时在当前时间加上超时时间，将订单ID放入进去，通过定时任务来定量拿取超时订单进行取消订单+补偿库存。</p><p><strong>添加订单到延时队列</strong></p><ul><li>当用户下单但未支付时，计算出订单的超时时间（例如：当前时间 + 30 分钟），然后将订单 ID 以这个时间为 score 添加到 Redis Sorted Set 中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">RScoredSortedSet&lt;String&gt; delayedQueue = redisson.getScoredSortedSet(<span class="hljs-string">&quot;delayed:order:queue&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">timeoutTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() + TimeUnit.MINUTES.toMillis(<span class="hljs-number">30</span>); <span class="hljs-comment">// 30分钟后超时</span><br>delayedQueue.add(timeoutTime, orderId);<br></code></pre></td></tr></table></figure><p><strong>定时任务检查并处理超时订单</strong></p><ul><li><p>定期运行一个后台任务，使用 <code>ZRANGEBYSCORE</code> 获取所有已经到期的订单（即 score 小于等于当前时间戳的所有订单）。</p></li><li><p>对于每个找到的订单，执行取消订单和补偿库存的操作，并从 Sorted Set 中移除这些订单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>Collection&lt;String&gt; expiredOrders = delayedQueue.valueRange(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, currentTime, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (String orderId : expiredOrders) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行取消订单逻辑</span><br>        cancelOrder(orderId);<br><br>        <span class="hljs-comment">// 补偿库存逻辑</span><br>        restoreStock(orderId);<br>        <br>        <span class="hljs-comment">// 从延迟队列中删除该订单</span><br>        delayedQueue.remove(orderId);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 异常处理</span><br>        logger.error(<span class="hljs-string">&quot;处理超时订单失败: &#123;&#125;&quot;</span>, orderId, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p> 这样的方案优点和方案一差不多，实时性好延迟小，但是就是过于依靠Redis，有数据丢失的风险。而且Redis是基于内存的，如果超时订单过多对Redis压力过大，容易挂机。</p><h1 id="方案三：MQ的延时消息🤩"><a href="#方案三：MQ的延时消息🤩" class="headerlink" title="方案三：MQ的延时消息🤩"></a>方案三：MQ的延时消息🤩</h1><p> 我们通过RocketMQ来讲这个例子，用户下单之后，生产者将设置好时间的消息发送给broker，等到规定的消息之后，该消息才对消费者可见，broker发送相应消息给消费者，消费者执行订单取消+库存补偿逻辑即可（消息重试机制保证消费者一定可以消费）</p><p><img src="https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a657816af14f4434b9d794ad41f2512d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oOz55Sob2ZmZXLmiZPniYw=:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNTc4NzgxNjQxOTY4OTcyIn0%253D&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1749190938&x-orig-sign=kibB6GjUR5t9J8I9LtwyUqjsPWw%253D&pos_id=img-ClWo8nz0-1749107416163" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p><p><strong>生产者：用户下单后发送延时消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RocketMQTemplate rocketMQTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderService</span><span class="hljs-params">(RocketMQTemplate rocketMQTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rocketMQTemplate = rocketMQTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(String orderId, String productKey)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建订单（伪代码）</span><br>        System.out.println(<span class="hljs-string">&quot;创建订单：&quot;</span> + orderId);<br><br>        <span class="hljs-comment">// 2. 预扣减库存（假设用 Redisson）</span><br>        <span class="hljs-comment">// RAtomicLong stock = redisson.getAtomicLong(productKey);</span><br>        <span class="hljs-comment">// stock.decrementAndGet();</span><br><br>        <span class="hljs-comment">// 3. 发送延迟消息，level=15 对应 30分钟</span><br>        <span class="hljs-type">OrderTimeoutMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderTimeoutMessage</span>(orderId, productKey);<br>        rocketMQTemplate.convertAndSend(<span class="hljs-string">&quot;ORDER_TIMEOUT_TOPIC&quot;</span>, message, <span class="hljs-literal">null</span>, <span class="hljs-number">15</span>); <span class="hljs-comment">// level=15</span><br>        System.out.println(<span class="hljs-string">&quot;已发送延迟消息，30分钟后处理订单：&quot;</span> + orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消费者：监听并处理超时订单</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RocketMQMessageListener(topic = &quot;ORDER_TIMEOUT_TOPIC&quot;, consumerGroup = &quot;order-timeout-group&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderTimeoutConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RocketMQListener</span>&lt;OrderTimeoutMessage&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(OrderTimeoutMessage message)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> message.orderId;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">productKey</span> <span class="hljs-operator">=</span> message.productKey;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">expectedExpireTime</span> <span class="hljs-operator">=</span> message.timestamp + TimeUnit.MINUTES.toMillis(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">// 1. 判断是否已经过期（防止重复消费或提前消费）</span><br>        <span class="hljs-keyword">if</span> (System.currentTimeMillis() &lt; expectedExpireTime) &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息尚未到期，跳过处理：&quot;</span> + orderId);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 查询订单状态（伪代码）</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">paid</span> <span class="hljs-operator">=</span> checkIfOrderPaid(orderId);<br>        <span class="hljs-keyword">if</span> (paid) &#123;<br>            System.out.println(<span class="hljs-string">&quot;订单已支付，无需处理：&quot;</span> + orderId);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 未支付 → 取消订单 + 补偿库存</span><br>        cancelOrder(orderId);<br>        restoreStock(productKey);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIfOrderPaid</span><span class="hljs-params">(String orderId)</span> &#123;<br>        <span class="hljs-comment">// 查询数据库判断是否已支付（伪逻辑）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 假设未支付</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelOrder</span><span class="hljs-params">(String orderId)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;取消订单：&quot;</span> + orderId);<br>        <span class="hljs-comment">// 实际操作：更新订单状态为已取消</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreStock</span><span class="hljs-params">(String productKey)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;补偿库存：&quot;</span> + productKey);<br>        <span class="hljs-comment">// 实际操作：INCR productKey</span><br>        <span class="hljs-comment">// RAtomicLong stock = redisson.getAtomicLong(productKey);</span><br>        <span class="hljs-comment">// stock.incrementAndGet();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你使用的RocketMQ是5.x的版本就可以支持任意时刻的延时消息了，否则就是对应级别的延时消息。</p><p>这种方案处理高并发性能好，而且处理消息丢失等方案成熟。缺点就是系统架构更加复杂了，需要处理MQ的其他问题，维护成本变高了。</p><h1 id="方案四：分布式定时任务调度框架😈"><a href="#方案四：分布式定时任务调度框架😈" class="headerlink" title="方案四：分布式定时任务调度框架😈"></a>方案四：分布式定时任务调度框架😈</h1><p>使用分布式定时任务调度框架，比如<strong>xxl-job 或 Quartz</strong>是企业里面非常常见的方案。用户下单之后，我们在数据库里面记录订单状态为“待支付”，然后通过xxl-job定期扫描过期的订单，筛选出超时未支付的订单，进行取消订单+补偿库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderTimeoutJobHandler</span> &#123;<br><br>    <span class="hljs-meta">@XxlJob(&quot;orderTimeoutJob&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orderTimeoutJob</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        XxlJobLogger.log(<span class="hljs-string">&quot;开始执行超时订单检测任务...&quot;</span>);<br><br>        <span class="hljs-comment">// 1. 获取当前时间</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><br>        <span class="hljs-comment">// 2. 查询所有 timeout_time &lt;= now 且 status = 0 的订单</span><br>        List&lt;Order&gt; expiredOrders = orderMapper.findExpiredOrders(now);<br><br>        <span class="hljs-keyword">for</span> (Order order : expiredOrders) &#123;<br>            <span class="hljs-comment">// 3. 加锁防止并发处理同一订单（可选 Redis 分布式锁）</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(<br>                <span class="hljs-string">&quot;lock:order:&quot;</span> + order.getId(), <span class="hljs-string">&quot;locked&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.MINUTES);<br><br>            <span class="hljs-keyword">if</span> (!locked) &#123;<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 已被其他节点处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 4. 再次确认是否已支付（防止并发问题）</span><br>                <span class="hljs-type">Order</span> <span class="hljs-variable">updatedOrder</span> <span class="hljs-operator">=</span> orderMapper.selectById(order.getId());<br>                <span class="hljs-keyword">if</span> (updatedOrder.getStatus() != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 5. 更新订单状态为“已取消”</span><br>                orderMapper.updateStatus(order.getId(), <span class="hljs-number">2</span>);<br><br>                <span class="hljs-comment">// 6. 补偿库存（如使用 Redisson）</span><br>                <span class="hljs-type">RAtomicLong</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisson.getAtomicLong(order.getProductKey());<br>                stock.incrementAndGet();<br><br>                XxlJobLogger.log(<span class="hljs-string">&quot;已取消订单：&quot;</span> + order.getId() + <span class="hljs-string">&quot;，补偿库存：&quot;</span> + order.getProductKey());<br><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 7. 释放锁</span><br>                redisTemplate.delete(<span class="hljs-string">&quot;lock:order:&quot;</span> + order.getId());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>笔者更加推荐xxl-job来实现分布式定时任务，因为它自带可视化界面，兼顾性能与精准，更适合微服务架构下的分布式任务调度</p><p>这种方案对实时性支持不是很好，且框架学习成本高。</p><h1 id="重复补偿库存问题😗"><a href="#重复补偿库存问题😗" class="headerlink" title="重复补偿库存问题😗"></a>重复补偿库存问题😗</h1><p>由于网络延迟或者网络分区，又或者是Redis服务器问题，还有并发问题等，有可能会导致重复补偿库存的情况，那么该怎么解决呢？</p><p><strong>1.使用分布式锁</strong></p><ul><li><p>在执行库存补偿之前，尝试获取一个针对特定商品 ID 的分布式锁。只有成功获取锁的进程才能执行补偿操作。这样可以防止多个实例同时处理同一个过期事件。</p></li><li><p>示例代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisson.getLock(<span class="hljs-string">&quot;lock:product:&quot;</span> + productId);<br><span class="hljs-keyword">if</span> (lock.tryLock()) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行库存补偿逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>2.状态标记</strong></p><ul><li><p>在补偿库存后，给对应的 key 添加一个特殊的标识（如 <code>compensated</code> 标记）。下次再遇到该 key 过期时，先检查是否存在这个标记。如果存在，则跳过补偿步骤。</p></li><li><p>示例代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!redissonMap.containsKey(productId + <span class="hljs-string">&quot;:compensated&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 执行库存补偿逻辑</span><br>    redissonMap.put(productId + <span class="hljs-string">&quot;:compensated&quot;</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>3.延迟队列结合定时任务</strong></p><p>刚才方案二就可以解决这个问题，将需要补偿的订单信息放入延迟队列中，并设置适当的延迟时间。通过后台定时任务统一处理这些订单，确保每个订单只被处理一次</p><p><strong>4.数据库唯一约束</strong></p><p>通过建立补偿库存表，业务和订单id作为唯一索引，每次补偿之前尝试是否可以插入该表，可以则补偿，反之则跳过。</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>实际业务不一定要按照上面的方案执行，可以根据实际来组合使用(●’◡’●)。如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer</p>]]></content>
    
    
    <categories>
      
      <category>后端开发问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>后端开发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解本地缓存Guava</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98Guava/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98Guava/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在后端开发中或者面试中，我们经常会谈到多级缓存这个概念，那么这里就要来说一说缓存的分类了。缓存分为本地缓存和分布式缓存（数据库缓存已经被废弃了），本地缓存常见的有Guava，Ehcache，Caffeine，分布式缓存常见的有Redis，Memcached。那么我们今天主要来聊聊本地缓存Guava。</p><h1 id="本地缓存的必要性🤤"><a href="#本地缓存的必要性🤤" class="headerlink" title="本地缓存的必要性🤤"></a>本地缓存的必要性🤤</h1><p>不是有了像redis这样的分布式缓存了吗，为什么还要本地缓存呢？因为本地缓存有这样的优势:</p><ol><li><strong>提升性能</strong></li></ol><ul><li><strong>减少延迟</strong>：通过在应用层引入本地缓存作为第一级缓存（L1），可以直接在进程内部快速响应查询请求，而不需要每次都访问更慢的外部存储（如远程缓存或数据库）。这显著减少了响应时间。</li><li><strong>减少IO</strong>：由于本地缓存可以命中部分数据，减少了与分布式缓存的交互，也就减少了IO次数，进而减少了网络开销</li></ul><ol start="2"><li><strong>减轻后端压力</strong></li></ol><ul><li><strong>降低负载</strong>：多级缓存策略可以有效减少对后端数据库或其他外部服务的直接访问次数，从而减轻这些资源的压力，提高整体系统的稳定性和可用性。</li></ul><ol start="3"><li><strong>增加缓存命中率</strong></li></ol><ul><li><strong>优化缓存利用率</strong>：不同的缓存级别可以根据其特点存储不同热度的数据。例如，本地缓存可以存放最常访问的数据，而分布式缓存则用于存放相对较少访问但仍然重要的数据。这种方式能够最大化利用各个层级缓存的优势，提高整体缓存命中率。</li></ul><ol start="4"><li><strong>容错能力增强</strong></li></ol><ul><li><strong>提供冗余</strong>：当一个级别的缓存发生故障或失效时，其他级别的缓存仍然可以提供一定程度的服务，避免了单点失败带来的严重影响，提高了系统的容错能力和可靠性。</li></ul><ol start="5"><li><strong>灵活性与可扩展性</strong></li></ol><ul><li><strong>易于调整和扩展</strong>：根据业务需求的变化，可以灵活地调整各级缓存的大小、过期策略等参数，甚至添加新的缓存层次，以适应不断变化的工作负载。</li></ul><h1 id="多级缓存访问流程🥹"><a href="#多级缓存访问流程🥹" class="headerlink" title="多级缓存访问流程🥹"></a>多级缓存访问流程🥹</h1><p>在<strong>多级缓存架构</strong>中，一般的设计模式是：</p><blockquote><p><strong>先查本地缓存（L1缓存） → 未命中则查分布式缓存（L2缓存） → 还未命中才查询数据库。</strong></p></blockquote><p>这种设计的目的在于<strong>兼顾性能与一致性</strong></p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNptkktLw0AQgP9KmHMsSdo0j4Oiffi-eTLxEMz2ASYpMQE1LYhi6UVUqqBYFBS9aB-eWrTin3G3_RmmSaoW3dPOzjfzLbvjwaalI5Ahb2ulArWWVk3KX7MKbt2RWnfw1B62u-TlgFx0yHFrg5qamqbmFHK_T24fSOMZNzqDfh03LzfCurkASHkrbHiMz94_e82ZSphNjbJlctkuU2ll-HGOr2_GYNT_N4dPH8tUJnLhWhX3DnH_ZEKXCXRZb4X7T5f90c2Pddw_uuyPbkHxXcP2XZjHr_UIWQhEiwruVAdvdXLTwNUrfPQwvv0EtfSH4iaoxYBajm4UmgZvV98PHmFLIQa0_zVFHWTHdhENBrINbRSCN8JUcArIQCrI_lZHOc3dclRQzYpfVtLMdcsyxpW25eYLIOe0rW0_cku65qB0UfP_3fg-tZGpIztluaYDMpsMeoDswQ7IfCLGsfG4ILEik-QkkeVp2AU5wccYXoonGF4UOJHj2QoNe4GViYmCJPFMXOIkJikIrEgD0ouOZa-GExcMXuUL67YPYQ"><img src="https://i-blog.csdnimg.cn/img_convert/62ca86269c2492b7bb15cf56b87eb86c.jpeg"></a></p><h1 id="使用Guava作为本地缓存😈"><a href="#使用Guava作为本地缓存😈" class="headerlink" title="使用Guava作为本地缓存😈"></a>使用Guava作为本地缓存😈</h1><p>首先要注意的是，Guava本身并不提供注解来使用缓存功能。Guava 提供了 <code>CacheBuilder</code> API 来以编程方式配置和使用缓存。</p><p>所以我们这里可以使用<strong>Spring Cache 集成 Guava</strong>的方式来使用guava的本地缓存功能，这样非常方便，因为它允许通过注解来（如 <code>@Cacheable</code>、<code>@CachePut</code> 和 <code>@CacheEvict</code>）来声明性地配置缓存。</p><h2 id="添加Spring-Cache-和-Guava-依赖"><a href="#添加Spring-Cache-和-Guava-依赖" class="headerlink" title="添加Spring Cache 和 Guava 依赖"></a>添加<strong>Spring Cache 和 Guava 依赖</strong></h2><p>在pom文件添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>33.4.8-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置Guava-CacheManager"><a href="#配置Guava-CacheManager" class="headerlink" title="配置Guava CacheManager"></a>配置<strong>Guava CacheManager</strong></h2><p>创建一个配置类，用于配置 <code>GuavaCacheManager</code> 作为 Spring 的缓存管理器。</p><p>记得在<strong>配置类或者启动类</strong>加上@EnableCaching</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuavaCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuavaCacheManager</span>();<br>        CacheBuilder&lt;Object, Object&gt; cacheBuilder = CacheBuilder.newBuilder()<br>                .maximumSize(<span class="hljs-number">100</span>)<br>                .expireAfterWrite(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>        cacheManager.setCacheBuilder(cacheBuilder);<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Cacheable-注解"><a href="#使用-Cacheable-注解" class="headerlink" title="使用@Cacheable 注解"></a>使用<code>@Cacheable</code> 注解</h2><p><code>@Cacheable</code> 是 Spring 框架中用于缓存管理的一个注解。它被用来标记一个方法，表示该方法的返回值可以被缓存起来。当再次调用这个方法，并且传入相同的参数时，框架会直接从缓存中获取结果，而不是重新执行方法体内的逻辑。这在减少数据库查询次数、提高应用性能方面非常有用。</p><p><strong>主要属性</strong></p><ul><li><strong>value&#x2F;cacheNames</strong>: 指定缓存的名称。这是必需的属性，因为它定义了缓存存储的位置（即哪个缓存）。</li><li><strong>key</strong>: 定义缓存的键，默认是使用方法的所有参数来生成。可以通过 SpEL（Spring Expression Language）自定义键值。</li><li><strong>condition</strong>: 可选属性，指定一个条件表达式，只有满足条件时才会进行缓存。例如，可以根据方法参数决定是否缓存结果。</li><li><strong>unless</strong>: 与 <code>condition</code> 相似，但它是在方法成功执行之后评估的。如果条件为真，则不会缓存方法的结果</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;books&quot;, key = &quot;#isbn&quot;)</span><br><span class="hljs-keyword">public</span> Book <span class="hljs-title function_">findBookByIsbn</span><span class="hljs-params">(String isbn)</span> &#123;<br>    <span class="hljs-comment">// 方法逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>findBookByIsbn</code> 方法的结果会被缓存到名为 “books” 的缓存中。缓存的键是传入的 <code>isbn</code> 参数值。如果多次调用 <code>findBookByIsbn</code> 方法并传递相同的 ISBN 值，那么第二次及以后的调用将直接从缓存中获取结果，而不会执行方法体中的逻辑。</p><p>ps：要注意缓存机制依赖于代理模式（AOP），因此 <code>@Cacheable</code> 注解不能应用于本类内部的方法调用，否则会失效😵</p><h2 id="使用-CachePut-注解"><a href="#使用-CachePut-注解" class="headerlink" title="使用@CachePut 注解"></a>使用<code>@CachePut</code> 注解</h2><p><code>@CachePut</code> 的作用是：无论缓存中是否存在数据，都会执行方法体，并将方法的返回值更新到缓存中</p><ul><li><strong>方法一定会执行</strong></li><li><strong>返回结果会写入缓存</strong></li><li>常用于<strong>更新操作后刷新缓存</strong></li></ul><table><thead><tr><th><code>value</code> &#x2F; <code>cacheNames</code></th><th>必填，指定缓存的名字（可以是一个或多个），如 <code>&quot;users&quot;</code></th></tr></thead><tbody><tr><td><code>key</code></td><td>可选，默认使用参数生成缓存键，可以通过 SpEL 表达式自定义，如 <code>#user.id</code></td></tr><tr><td><code>condition</code></td><td>可选，只有满足条件时才更新缓存，如 <code>#user.age &gt; 18</code></td></tr><tr><td><code>unless</code></td><td>可选，在方法执行之后判断，如果表达式为 true，则不更新缓存</td></tr></tbody></table><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@CachePut(value = &quot;users&quot;, key = &quot;#user.id&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">updateUser</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-comment">// 模拟更新数据库操作</span><br>        System.out.println(<span class="hljs-string">&quot;Updating user in database: &quot;</span> + user);<br>        <span class="hljs-keyword">return</span> user; <span class="hljs-comment">// 返回值会被放入缓存</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>当调用 <code>updateUser()</code> 方法时：</p><ul><li>不管缓存中有没有 <code>user.id</code> 对应的数据，方法都会执行</li><li>方法执行完毕后，返回值（即 <code>user</code>）会被写入名为 <code>&quot;users&quot;</code> 的缓存中，键为 <code>#user.id</code></li></ul></li><li><p>下次通过 <code>@Cacheable</code> 获取这个用户时，就会直接命中缓存</p></li></ul><h2 id="使用-CacheEvict-注解"><a href="#使用-CacheEvict-注解" class="headerlink" title="使用@CacheEvict 注解"></a>使用<code>@CacheEvict</code> 注解</h2><p><code>@CacheEvict</code> 用于<strong>清除缓存</strong>。它通常用于在执行某些操作（如删除或更新数据）后，清理相关的缓存条目，以保证缓存和底层数据源（如数据库）之间的一致性</p><p><strong><code>@CacheEvict</code> 的作用是：从缓存中移除一个或多个条目</strong>,你可以根据方法参数动态决定要清除的缓存键，也可以选择是否清除整个缓存区域（即清空整个缓存）。</p><table><thead><tr><th><code>value</code> &#x2F; <code>cacheNames</code></th><th>必填，指定要清除的缓存名称，如 <code>&quot;users&quot;</code></th></tr></thead><tbody><tr><td><code>key</code></td><td>可选，默认使用参数生成缓存键，可以通过 SpEL 自定义</td></tr><tr><td><code>allEntries</code></td><td>布尔值，默认 <code>false</code>，若为 <code>true</code>，则清除整个缓存区域的所有条目</td></tr><tr><td><code>beforeInvocation</code></td><td>默认 <code>false</code>，表示在方法执行<strong>之后</strong>清除缓存；若设为 <code>true</code>，则在方法执行<strong>之前</strong>清除</td></tr></tbody></table><p>简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(value = &quot;users&quot;, key = &quot;#userId&quot;, beforeInvocation = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUserById</span><span class="hljs-params">(String userId)</span> &#123;<br>    <span class="hljs-comment">// 删除数据库记录</span><br>&#125;<br></code></pre></td></tr></table></figure><p>即使方法抛出异常，缓存也会被清除（因为是在方法执行前进行的）</p><p><strong>示例：按 key 清除单个缓存项</strong></p><p>调用 <code>deleteUserById(&quot;123&quot;)</code> 时，会从 <code>&quot;users&quot;</code> 缓存中移除键为 <code>&quot;123&quot;</code> 的缓存项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@CacheEvict(value = &quot;users&quot;, key = &quot;#userId&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUserById</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-comment">// 模拟删除用户操作</span><br>        System.out.println(<span class="hljs-string">&quot;Deleting user from database: &quot;</span> + userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：清除整个缓存区域</strong></p><p>使用 <code>allEntries = true</code> 表示清除 <code>&quot;users&quot;</code> 缓存下的所有条目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(value = &quot;users&quot;, allEntries = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearAllUsersCache</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 不需要执行任何业务逻辑，仅用于清空缓存</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：结合条件判断是否清除缓存</strong></p><p>只有当 <code>#user.shouldBeRemoved == true</code> 时，才会清除该用户的缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(value = &quot;users&quot;, key = &quot;#user.id&quot;, condition = &quot;#user.shouldBeRemoved&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUserIfNecessary</span><span class="hljs-params">(User user)</span> &#123;<br>    <span class="hljs-comment">// 删除逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>后台缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>后台缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解Completable的用法基础(保姆版)</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3Completable%E7%9A%84%E7%94%A8%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BF%9D%E5%A7%86%E7%89%88/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3Completable%E7%9A%84%E7%94%A8%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BF%9D%E5%A7%86%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在后端开发中，我们经常会使用线程池来异步执行任务，但是如果要进行异步编排任务可犯了难。线程池可不能按照一定顺序来执行相应任务，所以今天我们来讲讲Java8引入的，位于<code>java.util.concurrent</code>包下的CompletableFuture。</p><p>如图是依靠CompletableFuture来实现的异步并行任务，聚合结果的示意图：</p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNpdkk1PwjAYx7_K8pyBANvYy0HDi6Ko8eLJjUPjyksc2zK3RCQkGGMC6oFET4oYT3rxJV48YPTL2MHHsLQQ1J767-_39GnTtmDPtTDoUPWRVxN2CqYj0JE1yEeHPJyXhXh8ScgZpP9Czh6FAB3sp8ozhaH8b5T-gwq_kUgRhzkGVwy2l0CeL6Juf1aXZ2iVofRfVGCoyJC4QByuMLjWQra9XRk_9cjnKTeW21xY5QIPxXngcY3FdSPqdaJB73s0Imf35P3tX4t1ZpWMyevJ-IpeqYadrOfZTWFyfE363fHoMhoOZmctMXfDmHxdkZthNOiMRwuBKxtM2TSmy7d3rA5i9A3qFuiBH-IYNLDfQNMIrSk1gbZsYBN0OrVwBYV2YILptGmZh5xd123MK303rNZAryD7gKbQs1CAC3VEH3ihYMfCft4NnQD0lMq2AL0Fh6CraiKjJZPpjCpqoqxoFDZBz4gJOanIqiiqsiQpitaOwRHrmUyoKUmTpIwqp2RNUzQpBtiqB66_xT8W-1_tH6OB3Wk"><img src="https://i-blog.csdnimg.cn/img_convert/c044196697a25ed6bc97096f01d9c64e.jpeg"></a></p><h1 id="Future😯"><a href="#Future😯" class="headerlink" title="Future😯"></a>Future😯</h1><p>要想了解CompletableFuture，我们就得先来了解一下Future。<code>Future</code> 是 Java 中用于表示异步计算结果的接口，它允许你启动一个长时间运行的任务，并在之后获取该任务的结果，而无需阻塞主线程。以下是该接口的主要方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">//尝试取消此任务的执行。如果任务已经完成、或已取消、或者由于某些原因无法取消，则此尝试将失败。如果成功取消了任务的执行，返回 true</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消,如果在任务正常完成前被取消，则返回 true</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成,无论任务是正常完成、异常终止还是被取消，只要任务完成就返回true</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 阻塞式获取任务执行结果，如果有错误发生（如任务抛出异常）</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 阻塞式获取任务执行结果，指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio<br><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，虽然 <code>Future</code> 提供了一种处理异步操作结果的方式，但它缺乏一些更高级的功能，比如组合多个异步操作的结果、异常处理等。</p><h1 id="CompletableFuture😎"><a href="#CompletableFuture😎" class="headerlink" title="CompletableFuture😎"></a>CompletableFuture😎</h1><p>因Future的局限性，Java8引入CompletableFuture来解决Future的不足，而且还带来了新特性，让我们一起来看看。</p><h2 id="创建CompletableFuture😪"><a href="#创建CompletableFuture😪" class="headerlink" title="创建CompletableFuture😪"></a>创建CompletableFuture😪</h2><p><strong>1.new（即手动创建CompletableFuture）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li>可以在后续通过 <code>.complete()</code> 或 <code>.completeExceptionally()</code> 手动设置结果或异常。</li><li><strong>适合</strong>：需要跨线程通信、事件驱动等自定义控制流程的场景</li></ul><p><strong>2.工厂方法 <code>supplyAsync()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span><br></code></pre></td></tr></table></figure><p>两者的区别在于是否传入自定义线程池，前者使用默认线程池ForkJoinPool.commonPool()，后者可传入自定义的线程池。这个方法创建的CompletableFuture可执行一个带返回值的异步任务。</p><p><strong>3.工厂方法 <code>runAsync()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">runAsync</span><span class="hljs-params">(Runnable runnable, Executor executor)</span><br></code></pre></td></tr></table></figure><p>这两个方法的区别和supplyAsync()的两者区别一样。这个方法创建的CompletableFuture可执行一个没有返回值的异步任务。</p><p><strong>4. <code>completedFuture()</code>创建已完成状态的 Future</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">completedFuture</span><span class="hljs-params">(U value)</span><br></code></pre></td></tr></table></figure><p>直接创建一个已经完成并带有结果的 <code>CompletableFuture</code>，可以用于测试、快速返回已知结果、跳过某些分支逻辑</p><p>其实这个方法底层用的是new，即手动创建CompletableFuture，封装起来罢了😗</p><h2 id="组合编排CompletableFuture🫨"><a href="#组合编排CompletableFuture🫨" class="headerlink" title="组合编排CompletableFuture🫨"></a>组合编排CompletableFuture🫨</h2><p>上面说了CompletableFuture可以进行异步组合编排任务，那么到底是怎么样进行组合编排的呢？</p><h3 id="链式调用-thenCompose"><a href="#链式调用-thenCompose" class="headerlink" title="链式调用.thenCompose()"></a>链式调用<code>.thenCompose()</code></h3><p>这个方法主要用于<strong>异步任务的串行编排</strong>。简单来说，<code>thenCompose()</code> 用于将一个异步任务的结果作为输入，继续发起一个新的异步任务，形成一条异步流水线。</p><p>在下面这个例子中，通过工厂方法创建了一个CompletableFuture之后，接着将结果输入给新CompletableFuture作为参数，然后输出结果。</p><ol><li>第一个任务返回 <code>&quot;Hello&quot;</code>；</li><li>第二个任务接收 <code>&quot;Hello&quot;</code>，并异步返回 <code>&quot;Hello World&quot;</code>；</li><li><code>thenCompose()</code> 把两个 Future <strong>合并成一个连续的 Future</strong>，而不是嵌套的 <code>CompletableFuture&lt;CompletableFuture&lt;String&gt;&gt;</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello&quot;</span>)<br>    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="hljs-string">&quot; World&quot;</span>));<br><br>System.out.println(future.join()); <span class="hljs-comment">// 输出 Hello World</span><br></code></pre></td></tr></table></figure></li></ol><p>太简单了？来点难度的，模拟多级异步调用。<br>假设你有如下三个服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 token</span><br>CompletableFuture&lt;String&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(String username)</span> &#123;<br>    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;token-&quot;</span> + username);<br>&#125;<br><br><span class="hljs-comment">// 根据 token 获取用户信息</span><br>CompletableFuture&lt;User&gt; <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(String token)</span> &#123;<br>    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(token));<br>&#125;<br><br><span class="hljs-comment">// 根据用户信息获取订单列表</span><br>CompletableFuture&lt;List&lt;Order&gt;&gt; <span class="hljs-title function_">getOrders</span><span class="hljs-params">(User user)</span> &#123;<br>    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;1001&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-string">&quot;1002&quot;</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>thenCompose()</code> 编排整个流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = login(<span class="hljs-string">&quot;alice&quot;</span>)<br>    .thenCompose(token -&gt; getUserInfo(token))<br>    .thenCompose(user -&gt; getOrders(user));<br><br>List&lt;Order&gt; orders = ordersFuture.join();<br>orders.forEach(order -&gt; System.out.println(<span class="hljs-string">&quot;订单ID：&quot;</span> + order.id));<br></code></pre></td></tr></table></figure><p>这样我们就通过thenCompose()实现了多个异步服务的链式调用，下面是一个链式调用的简单示意图<br><a href="https://mermaid-live.nodejs.cn/edit#pako:eNqNkstuwjAQRX_FGrYBBfJyvKhEoOy6aVk1YWHIhEQkdmQ7aini35sHr0Vb1ZKlmdG5c-XxnGAnUwQGe8XrnKyXiSDtmcdvhiuzIePxE1lzfZgP9T6MF7KqSzR8W-KqMY1CMicZml2-5IbP9VHsLsIcRcdKjRf5vRCbe0w-CpP3vUl0t4zultEPlhGpldyh1p3poHoW6SvqpjSD8pbGq0LwkgzJDY3bS2RGFjkvxCYRg0ibY9m_pyhLNsrCzNJGyQOykeM4j0inHqDt9leon9e1F0c7oH-R0f_Ih8ENPJ-mbmg_8mC1H1qkwIxq0IIKVcW7FE5dpwTa4VeYAGvDFDPejQwScW5lNRfvUlZXpZLNPgeW8VK3WVOn3OCy4O22VLeqQpGiWshGGGCzWd8D2Ak-gVE68UPbnvnUCR0vCKkFR2C-M_HswKOOQz3XDYLwbMFXb2pP6NQNXdenrmd7rj_zLcC0MFK9DGvab-v5G3F23NE"><img src="https://i-blog.csdnimg.cn/img_convert/b1190ad1a9526048b7550971ea57f1f6.jpeg"></a></p><h3 id="合并处理-thenCombine"><a href="#合并处理-thenCombine" class="headerlink" title="合并处理.thenCombine()"></a>合并处理<code>.thenCombine()</code></h3><p>上面讲解了如何链式调用任务，属于是微信接龙形态的（hh，开个玩笑），现在我们来讲<strong>并行执行两个异步任务，并将它们的结果合并处理</strong>。</p><p>简单来说，**<code>thenCombine()</code> 用于将两个独立的 <code>CompletableFuture</code> 的结果进行合并处理，返回一个新的结果**，就能实现这样的效果。</p><p>适合用于：</p><ul><li>同时发起多个异步请求（如查询用户信息、查询订单信息）</li><li>然后在两者都完成后，把结果合并输出</li></ul><p>废话不多说，例子走起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello&quot;</span>);<br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">//第一个参数是另一个异步任务，第二个参数是合并结果的具体逻辑</span><br>CompletableFuture&lt;String&gt; combinedFuture = future1.thenCombine(future2, (result1, result2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> result1 + <span class="hljs-string">&quot; &quot;</span> + result2; <span class="hljs-comment">// 合并结果</span><br>&#125;);<br><br>System.out.println(combinedFuture.join()); <span class="hljs-comment">// 输出 Hello World</span><br></code></pre></td></tr></table></figure><ul><li><code>future1</code> 和 <code>future2</code> 是<strong>并行执行</strong>的。</li><li>当两者都完成时，使用 <code>thenCombine()</code> 将它们的结果拼接起来。</li></ul><p>不够接近真实业务？上点难度：</p><p>假设你有两个服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模拟根据用户ID获取用户名</span><br>CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchUserName</span><span class="hljs-params">(<span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>        <span class="hljs-comment">// 模拟网络延迟</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Alice&quot;</span>;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 模拟根据用户ID获取订单数量</span><br>CompletableFuture&lt;Integer&gt; <span class="hljs-title function_">fetchOrderCount</span><span class="hljs-params">(String userName)</span> &#123;<br>    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>        Thread.sleep(<span class="hljs-number">800</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以这样使用 <code>thenCombine()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><br>CompletableFuture&lt;String&gt; userFuture = fetchUserName(userId);<br>CompletableFuture&lt;Integer&gt; orderFuture = fetchOrderCount(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 假设已知用户名</span><br><br>CompletableFuture&lt;String&gt; resultFuture = userFuture.thenCombine(orderFuture, (name, count) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户：&quot;</span> + name + <span class="hljs-string">&quot;，订单数：&quot;</span> + count;<br>&#125;);<br><br>System.out.println(resultFuture.join());<br><span class="hljs-comment">// 输出：用户：Alice，订单数：5</span><br></code></pre></td></tr></table></figure><ul><li><code>thenCombine()</code> 不会等待两个 Future 的异常状态，如果其中一个失败，整个 Future 也会失败。</li><li>如果你想处理异常或提供默认值，可以结合 <code>.exceptionally()</code> 或 <code>.handle()</code> 使用。</li></ul><p><strong>进阶：链式调用多个 <code>thenCombine()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">10</span>);<br>CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">20</span>);<br>CompletableFuture&lt;Integer&gt; f3 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">30</span>);<br><br>CompletableFuture&lt;Integer&gt; result = f1.thenCombine(f2, Integer::sum)<br>                                     .thenCombine(f3, Integer::sum);<br><br>System.out.println(result.join()); <span class="hljs-comment">// 输出 60</span><br></code></pre></td></tr></table></figure><p>下面是一个简单的thenCombine()的示意图：<br><a href="https://mermaid-live.nodejs.cn/edit#pako:eNqNk0tLxDAUhf9KuG7rMH2nWQjz0J0g6MrWRaa5nZZpkyFNQR3mv5tpOr5QMdCQe_jOaXuTHKBUAoHBVvN9TR7WhSR2LPJ7w7V5IpeXV-SB97vFpL8LSye4eSTyler2LRq-afFmMINGi1doynrNDfddlmU2jcQP2_IH2_LDFvxgc_Mk5aZGOa1Jh3qLRGM_tKZ3zjutSuz7iRDO-03Mp5qUkzBFuIRrKXL7EFWRVc0b-VRIl9Kbl3b8x6Zt2UWVVV5vtNohuwjD8DNycjtos_kVGnt4zuI4T-lf5PJf5LkvjuW-iLL5b-y3nkyeUgiKX74ZPHtWGgHM6AE9sC3v-KmEwymtALsfHRbA7FJgxW0bCyjk0dr2XD4q1Z2dWg3bGljF295Ww15wg-uG24PYvasapUC9UoM0wAI6ZgA7wDMwSmdxFARJnGRh4MdR6MELsCScpUHmZzTOEpokYXr04HV86XxG_SiLonSextRPo9gDFI1R-tZdgPEeHN8AOOP5Ew"><img src="https://i-blog.csdnimg.cn/img_convert/3e7186f907af91c4ead92daabaf9969c.jpeg"></a></p><h3 id="等待全部allOf"><a href="#等待全部allOf" class="headerlink" title="等待全部allOf()"></a>等待全部<code>allOf()</code></h3><p>上面两个方法所要求的异步任务之间都是有联系的，但是实际上我们业务也有很多没关联的异步任务，比如文件上传，下载等，需要同时开启多个任务来执行，<strong>等待全部完成</strong>之后再统一返回结果或者成功标识。</p><p><code>allOf()</code>就可以完成这样的效果，它可以用于<strong>并行执行多个异步任务</strong>、并在<strong>所有任务完成后再继续后续操作</strong>。但是它不会<strong>不会自动聚合各个 Future 的结果</strong>（不关心是否返回结果，完成就行），你需要手动获取每个 Future 的值。</p><p>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Result1&quot;</span>);<br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Result2&quot;</span>);<br>CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Result3&quot;</span>);<br><span class="hljs-comment">//你直接对allFutures使用join()是无法获取结果的,因为allOf()不关心结果</span><br>CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(future1, future2, future3);<br><br>allFutures.thenRun(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;所有任务已完成！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;future1: &quot;</span> + future1.join());<br>    System.out.println(<span class="hljs-string">&quot;future2: &quot;</span> + future2.join());<br>    System.out.println(<span class="hljs-string">&quot;future3: &quot;</span> + future3.join());<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果任意一个 Future 抛出异常，整个 <code>allOf</code> 也会失败，可以使用<code>.exceptionally()</code> 或 <code>.handle()</code> 来捕获和处理异常。</p><p><strong>进阶：结合 <code>thenApply()</code> 聚合结果</strong><br>如果你想在所有任务完成后<strong>合并结果</strong>，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;List&lt;String&gt;&gt; combinedFuture = CompletableFuture.allOf(future1, future2, future3)<br>    .thenApply(v -&gt; List.of(<br>        future1.join(),<br>        future2.join(),<br>        future3.join()<br>    ));<br><br>List&lt;String&gt; results = combinedFuture.join();<br>System.out.println(results); <span class="hljs-comment">// 输出 [Result1, Result2, Result3]</span><br></code></pre></td></tr></table></figure><p>以下是allOf()的一个简单示意图：<br><a href="https://mermaid-live.nodejs.cn/edit#pako:eNqNk91q4zAQhV9FTG-d4MSOf8RSSJz2bsnFFhbW7oVijRpTWTKyzG435N1XseKmhXapQEIz-s4ZNEhHqDVHoPBkWHcgD9tKETd-WGZsOa6PZDa7JQ-sf16_OXtNbj5KFpXy6VFWnleyJjMi0NaHLbPMm66l3IkruPHgxoGd0TX2_YdY4bFixLBjBt9hHhyD8idrLBHaECYlsU51cdypQredRIuevsblTpHa7xutvu3N7XqSEq7VpdSd4qWbRAtyL_Xvx6lqb18kXnohGinpjchF0Fujn5HeRFH0FjsbeGi__xQaGzh5MQzT7H_k5stk8SVy7OJEirqu95-R1w5e8JrzDN9dCwL3yBoO1JoBA2jRtOwcwvFsVIE9YIsVULflKNggbQWVOjlZx9QvrdtJafTwdAAqmOxdNHScWdw2zL3g9jVrUHE0hR6UBRrFowfQI_wBmibzMM-ScJUso3CxWC4DeAGaRPM8yeJslUcrdxJmySmAv2PVcJ4t4jyO0zBdZYs0jvMAkDdWm-_-74xf6PQP5SIH1g"><img src="https://i-blog.csdnimg.cn/img_convert/7db9f23390d03c933aa276ae265789c6.jpeg"></a></p><h3 id="就等一个anyOf"><a href="#就等一个anyOf" class="headerlink" title="就等一个anyOf()"></a>就等一个<code>anyOf()</code></h3><p><code>anyOf()</code>用于<strong>并行执行多个异步任务</strong>、并在<strong>第一个任务完成（无论成功或失败）后立即返回结果</strong>的场景</p><p>适合用于：</p><ul><li>多个服务提供者并发调用，取<strong>最快响应</strong></li><li>实现“超时降级”逻辑</li><li>异常容忍：只要有一个 Future 成功即可继续流程</li></ul><p>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result from future1&quot;</span>;<br>&#125;);<br><br>CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result from future2&quot;</span>;<br>&#125;);<br><br>CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">800</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result from future3&quot;</span>;<br>&#125;);<br><br>CompletableFuture&lt;Object&gt; resultFuture = CompletableFuture.anyOf(future1, future2, future3);<br><br>System.out.println(<span class="hljs-string">&quot;最快完成的是：&quot;</span> + resultFuture.join());<br></code></pre></td></tr></table></figure><p><strong>进阶：结合 <code>filter()</code> 和 <code>handle()</code> 做降级处理</strong><br>你可以使用 <code>.handle()</code> 来统一处理成功&#x2F;失败情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; fastFuture = CompletableFuture.anyOf(future1, future2, future3)<br>    .handle((result, ex) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>            System.err.println(<span class="hljs-string">&quot;发生异常：&quot;</span> + ex.getCause());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;默认值&quot;</span>; <span class="hljs-comment">// 异常降级</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result.toString(); <span class="hljs-comment">// 正常返回</span><br>    &#125;);<br><br>System.out.println(fastFuture.join());<br></code></pre></td></tr></table></figure><p>下面是anyOf()的简单示意图<br><a href="https://mermaid-live.nodejs.cn/edit#pako:eNptkk1LwzAYx79KeM5d6fpm14PgNudUxIsn2x2KTd3AtqO2oI7BDgrqVAZ60jERDxNx6kUYzJcvs7Z-DLO0EybmlH9-vzxPSNKALdfEoMK2Z9SraKOoO4iMBS18b4X9dgVlMvMor4Wdl_D0AVmBH3g4W0klCguzkJ-BxVkoEJjgPMWLWloRRSf977uz8XDAsmxaoUCVUqrw_ylFqiylivBXSaRFKpUbhrO_bqF4cBJ-HjUTVEpQEpamIYllGpe16L4VvbXD49fotjMePqIS7YXC57PouJOeY5m6K9r311V404ufnsbDFnETJ74-jEeXUa-byitUXiU3cxGPBtHl-fijG4_6kzk9fgUY8ho1E1TfCzADNvZsYxKhMSmgg1_FNtZBJVMTW0aw4-ugO02yrW44m65rT3d6brBdBdUydnZJCuqm4eNizSBPbf-uetgxsVdwA8cHVVBoDVAbsAfqnMxyOUXmJJkXuGyW5xnYB1UW2JysiIqUEyRCOEVuMnBAu3KskhVzokiwxEmizMsMYLPmu95a8snoX2v-ABHM6VQ"><img src="https://i-blog.csdnimg.cn/img_convert/06dfa333c4ac57d9d149880829b3e631.jpeg"></a></p><h2 id="处理CompletableFuture异步结果😵"><a href="#处理CompletableFuture异步结果😵" class="headerlink" title="处理CompletableFuture异步结果😵"></a>处理CompletableFuture异步结果😵</h2><p>上面讲了这么多异步编排的方法，那么可不可以对单个异步任务进行处理的方法呢？有的，兄弟，有的，这样常用的方法有四个🤣</p><h3 id="thenApply"><a href="#thenApply" class="headerlink" title="thenApply()"></a><code>thenApply()</code></h3><p><code>thenApply()</code> 是 <code>CompletableFuture</code> 提供的一个方法，用于在<strong>异步任务完成之后</strong>，对结果进行<strong>转换处理</strong>。它返回一个新的 <code>CompletableFuture</code>，表示经过转换后的新结果。</p><p><strong>特点：</strong></p><ul><li><strong>串行执行</strong>：前一个任务完成后，才执行 <code>thenApply()</code> 中的任务。</li><li><strong>有返回值</strong>：<code>thenApply()</code> 会返回一个新的结果（即转换后的结果）。</li><li>类似于函数式编程中的 <code>map</code> 操作。</li></ul><p>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello&quot;</span>);<br><br><span class="hljs-comment">//输出是Hello World</span><br>future.thenApply(result -&gt; result + <span class="hljs-string">&quot; World&quot;</span>)<br>       .thenAccept(finalResult -&gt; System.out.println(finalResult));<br></code></pre></td></tr></table></figure><h3 id="thenAccept-和thenRun"><a href="#thenAccept-和thenRun" class="headerlink" title="thenAccept()和thenRun()"></a><code>thenAccept()</code>和<code>thenRun()</code></h3><p>现在着重讲一下这两个方法的区别。</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>thenAccept()</code></td><td><strong>消费结果</strong>，接收上一个任务的结果，但不返回新的值（无返回）</td></tr><tr><td><code>thenRun()</code></td><td><strong>执行动作</strong>，不接收上一个任务的结果，只在任务完成后执行一段逻辑</td></tr></tbody></table><p>它们都是用于在 <code>CompletableFuture</code> 完成后做一些后续处理，<strong>常用于链式调用中的“副作用”操作</strong>。</p><p>与 <code>thenApply()</code> 的区别？</p><table><thead><tr><th>方法名</th><th>是否接收前一个 Future 的结果</th><th>是否有返回值</th><th>是否支持链式调用</th><th>是否异步</th></tr></thead><tbody><tr><td><code>thenApply()</code></td><td>✅ 是</td><td>✅ 是（新值）</td><td>✅ 支持</td><td>✅ 异步</td></tr><tr><td><code>thenAccept()</code></td><td>✅ 是</td><td>❌ 否（void）</td><td>❌ 不传递值</td><td>✅ 异步</td></tr><tr><td><code>thenRun()</code></td><td>❌ 否</td><td>❌ 否（void）</td><td>❌ 不传递值</td><td>✅ 异步</td></tr></tbody></table><p><code>thenAccept()</code>的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello&quot;</span>);<br><br>future.thenAccept(result -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;接收到结果: &quot;</span> + result);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>接收上一个 Future 的结果作为输入</li><li>执行一个消费型操作（如打印、写日志、入库等）</li><li><strong>没有返回值</strong></li></ul><p><code>thenRun()</code>的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;正在执行主任务...&quot;</span>);<br>&#125;);<br><br>future.thenRun(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;主任务完成，执行后续清理操作&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>不接收上一个 Future 的结果</strong></li><li>只在 Future 完成后执行一个 Runnable 任务</li><li>适合用于执行一些不需要依赖结果的后续操作，比如发送通知、清理资源等</li></ul><p>注意：这两个方法都不会影响链式调用的返回值！一个负责消费结果，另一个负责后续动作。</p><h3 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete()"></a><code>whenComplete()</code></h3><p><strong><code>whenComplete()</code> 是一个回调方法，用于在 Future 完成（无论是正常完成还是异常完成）后执行一段逻辑。</strong></p><p>常用于：</p><ul><li>日志记录</li><li>资源清理</li><li>异常监控</li><li>最终结果处理</li></ul><p><strong>基本用法：正常完成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello World&quot;</span>)<br>    .whenComplete((result, throwable) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (throwable == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;任务完成，结果为: &quot;</span> + result);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.err.println(<span class="hljs-string">&quot;任务出错: &quot;</span> + throwable.getMessage());<br>        &#125;<br>    &#125;);<br><br>System.out.println(future.join()); <span class="hljs-comment">// 输出 Hello World</span><br></code></pre></td></tr></table></figure><p><strong>基本用法：异常处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;).whenComplete((result, throwable) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (throwable != <span class="hljs-literal">null</span>) &#123;<br>        System.err.println(<span class="hljs-string">&quot;捕获到异常：&quot;</span> + throwable.getMessage());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;任务成功完成，结果是：&quot;</span> + result);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 可以继续链式调用</span><br>future.thenAccept(System.out::println); <span class="hljs-comment">// 不会执行，因为前面抛异常了</span><br></code></pre></td></tr></table></figure><h1 id="CompletableFuture与线程池😈"><a href="#CompletableFuture与线程池😈" class="headerlink" title="CompletableFuture与线程池😈"></a>CompletableFuture与线程池😈</h1><p>CompletableFuture与线程池并不是相互矛盾的，而是相辅相成的。他们都有各自注重的领域，一个更注重异步任务编排，一个更加注重线程资源的管理。而且我们非常推荐使用自定义的线程池来使用CompletableFuture！</p><p>ps：如果都是用同一个默认线程池如 <code>ForkJoinPool.commonPool()</code>，可能会发生资源争抢等问题！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 supplyAsync 并指定自定义线程池</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;, customExecutor);<br></code></pre></td></tr></table></figure><h1 id="join-和-get-😫"><a href="#join-和-get-😫" class="headerlink" title="join() 和 get()😫"></a>join() 和 get()😫</h1><p>在使用 <code>CompletableFuture</code> 时，选择 <code>join()</code> 还是 <code>get()</code> 主要取决于你对异常处理的需求以及是否需要更细粒度的控制超时。两者的主要区别在于它们如何处理异常和超时：</p><p> <code>join()</code></p><ul><li><strong>抛出未经检查的异常（Unchecked Exceptions）</strong> ：如果 Future 完成时带有异常，<code>join()</code> 会抛出一个未检查的 <code>CompletionException</code>，这使得代码看起来更加简洁，尤其是在 Lambda 表达式中。</li><li><strong>不支持超时参数</strong>：如果你不需要设置超时时间来等待结果，<code>join()</code> 是一个不错的选择。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();<br>&#125; <span class="hljs-keyword">catch</span> (CompletionException e) &#123;<br>    <span class="hljs-comment">// 处理异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <code>get()</code></p><ul><li><strong>抛出经检查的异常（Checked Exceptions）</strong> ：包括 <code>InterruptedException</code> 和 <code>ExecutionException</code>。这意味着你需要在方法签名中声明这些异常或在调用处捕获它们。</li><li><strong>支持超时参数</strong>：允许你指定等待结果的最大时间，这对于避免无限期等待某些操作完成特别有用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">1</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 等待最多1秒</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 当前线程被中断时执行</span><br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>    <span class="hljs-comment">// 当Future完成时发生异常</span><br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    <span class="hljs-comment">// 超过指定时间未完成任务</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用建议</strong></p><ul><li><p><strong>推荐使用 <code>join()</code> 的场景</strong>：</p><ul><li>当你希望保持代码简洁，并且不想处理复杂的异常结构时。</li><li>在大多数情况下，尤其是当你已经在更高的层次上实现了异常处理逻辑时，<code>join()</code> 提供了一种更直接的方式来获取结果。</li></ul></li><li><p><strong>推荐使用 <code>get()</code> 的场景</strong>：</p><ul><li>当你需要对超时进行精确控制时。</li><li>如果你需要明确区分不同类型的异常（如中断、执行错误等），以便采取不同的恢复措施。</li></ul></li></ul><p>总的来说，在没有特殊需求的情况下（例如不需要超时控制），<strong>更推荐使用 <code>join()</code></strong> ，因为它简化了异常处理流程，使代码更加清晰易读。不过，具体选择应基于你的实际需求和上下文环境。</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Java并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解CAP理论</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3CAP%E7%90%86%E8%AE%BA/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3CAP%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>现代网站搭建的一般都是分布式系统，而聊到分布式系统的设计与构建，那就无法避开CAP理论，今天来聊一下CAP理论</p><h1 id="CAP定义😪"><a href="#CAP定义😪" class="headerlink" title="CAP定义😪"></a>CAP定义😪</h1><p>cap理论是指设计分布式系统时，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三个属性最多只能同时满足两个。</p><ol><li><strong>一致性（Consistency）</strong> ：每个读操作都能看到最近一次写操作的结果。在这个前提下，所有的节点在同一时间点上看到的数据是一致的。这与ACID事务中的一致性概念相似。CAP理论中的一致性是指强一致性，即所有节点在同一时间看到相同的数据。</li><li><strong>可用性（Availability）</strong> ：系统持续响应请求的能力。即使出现一个或多个节点故障，整个系统仍然能够处理请求，并返回响应。</li><li><strong>分区容忍性（Partition tolerance）</strong> ：系统能够在网络分区的情况下继续运作。网络分区指的是由于网络原因导致分布式系统中的部分节点之间无法通信的情况<br><a href="https://mermaid-live.nodejs.cn/edit#pako:eNp9UtFOgzAU_ZXmPpgtYcuEwYAHE8amvmj2wJN0DxXuRhNol1LUSfh3O3A6o7Ev7ek5556b9raQyRwhhL1ih4IkKyqIWVEaRxuSFCgVVlsymdyQZRpLUfNao8iO209Zz8Rp9MJ4yZ55yfVPapVumNJccylIIktUTGRoFINm2WvWbVxIWSNJXmU3EPFADGB1BgNc9_B2FG_IhFy0RK7IH1njS9PdKDqZLrv91_XtvE8pxNGvwMtKlIrRo9TkoFimecZKwgVRaPb6aAxVPaawBcs8NM8h1KpBCypUFTtBaE-JFHSBFVIIzTHHHWtKTYGKztgOTDxJWZ2dSjb7AsIdK2uDmkPONK44M79Yfd0qFDmqWDZCQ-h4fl8EwhbeIFwE07ln-45r-zPPmblzC44QXtvuNHDswPYCxw1m_nzeWfDex86mC2fhniyB5weubQcWYM61VA_DAPVz1H0AeL-z0g"><img src="https://i-blog.csdnimg.cn/img_convert/32a711b82803bb2f0c7b7de2dba006d6.jpeg"></a></li></ol><h1 id="CA-CP-AP😵"><a href="#CA-CP-AP😵" class="headerlink" title="CA,CP,AP😵"></a>CA,CP,AP😵</h1><h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><p>ca是指放弃了分区容忍性，选择可用性和一致性，但是这样就不符合分布式系统的设计初衷，在实践中，由于网络分区几乎是不可避免的，因此这种组合实际上很少被考虑。在这里就不做多解释</p><h2 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h2><p>ca是指放弃了可用性，优先选择一致性和分区容忍性。那么系统在遇到网络分区时，会优先保证数据的一致性，可能会牺牲系统的可用性。</p><p>在需要强一致性的场景，就需要选择cp来作为指导原则。如银行转账、交易系统等，应选择CP系统，保证数据的一致性。为了保证各个节点数据的强一致性，放弃了可用性，所以当某个分区出现故障，系统可以不断重试直到分区恢复可用，事务统一成功或者统一失败。</p><h2 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h2><p>ap是指放弃了一致性，优先选择可用性和分区容忍性。则在网络分区发生时，系统会优先保证可用性，可能会牺牲一致性。</p><p>在需要强一致性的场景，就需要选择ap来作为指导原则。如社交网络、电商网站等，可以选择AP系统，保证系统的可用性。放弃了一致性，我们可以选择合适多的分区，这样用户访问速度和体验感就越高，实现高可用性，当数据写入主节点之后，通过异步方式同步数据到其他节点。</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>注意，在一个系统中，cap并不是三选二的情形，也可以在不同场景中选择不同的组合。这意味着在实际应用中，系统可以在不同时间点对不同的操作做出不同的权衡。此外，现代分布式系统通常通过各种方式来尽量平衡三者之间的关系，以达到最佳实践效果。在不同的业务场景下，可以根据实际需求动态调整一致性和可用性的优先级。</p><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解BASE理论</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3BASE%E7%90%86%E8%AE%BA/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3BASE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="引言😵"><a href="#引言😵" class="headerlink" title="引言😵"></a>引言😵</h1><p>由于CAP理论的严格性，我们急需一种构建高可用，可扩展的分布式互联网应用的指导原则，于是出现了BASE理论。BASE理论强调系统的可用性和最终一致性，而不是强一致性。下面让我们一起了解一下。</p><h1 id="Basically-Available（基本可用）😯"><a href="#Basically-Available（基本可用）😯" class="headerlink" title="Basically Available（基本可用）😯"></a>Basically Available（基本可用）😯</h1><p><strong>定义：</strong>在分布式系统中，即使发生不可预知的故障，系统也要保证<strong>核心功能仍然可用</strong>，即使不是全部功能都能正常运行，提升系统的容错能力和可用性。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><strong>负载均衡</strong>：通过将请求分发到多个服务器，避免单点故障，确保部分服务器可用时，系统仍能响应请求。</li><li><strong>服务降级</strong>：当系统资源紧张或出现故障时，关闭部分非核心功能，保证核心功能的可用性。</li><li><strong>数据备份</strong>：通过数据冗余备份，当主节点故障时，可以快速切换到备用节点，保证数据的可用性。</li><li><strong>削峰减流</strong>：使用消息队列集群来抵挡突发的流量冲击，按照一定速率给数据库消费。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><strong>电商网站</strong>：在促销活动期间，即使部分服务器压力过大，仍然保证用户可以浏览商品和下单。</li><li><strong>社交网络</strong>：即使部分服务器出现故障，仍然保证用户可以查看和发布动态。</li><li><strong>在线游戏</strong>：即使部分服务器不稳定，仍然保证用户可以进行游戏。</li></ul><h1 id="Soft-State（软状态）😪"><a href="#Soft-State（软状态）😪" class="headerlink" title="Soft State（软状态）😪"></a>Soft State（软状态）😪</h1><p><strong>定义：系统中的数据可以存在中间状态，不要求所有数据时刻保持一致性</strong>。</p><p>简单来说，就是数据可能暂时不一致，状态可能会随着时间变化而自动更新，且不要求系统立即同步所有节点的数据。这里就代表了牺牲强一致性。</p><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a><strong>实现方式</strong>：</h2><ul><li><strong>异步复制</strong>：主节点将数据变更异步复制到备用节点，允许数据在一段时间内存在不一致。</li><li><strong>最终一致性协议</strong>：使用如Paxos、Raft等一致性协议，保证数据在经过一段时间的同步后，最终达到一致的状态。</li></ul><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景</strong>：</h2><ul><li><strong>电商网站</strong>：用户下单后，订单状态的更新可能存在延迟，但最终会更新为已支付或已发货状态。</li><li><strong>社交网络</strong>：用户发布动态后，动态的显示可能存在延迟，但最终会显示在所有用户的timeline中。</li><li><strong>在线游戏</strong>：玩家的等级和装备信息可能存在延迟，但最终会同步到所有客户端。</li></ul><h1 id="Eventually-Consistent（最终一致）😗"><a href="#Eventually-Consistent（最终一致）😗" class="headerlink" title="Eventually Consistent（最终一致）😗"></a>Eventually Consistent（最终一致）😗</h1><p><strong>定义：</strong> 所有对系统的更新操作，在经过一段时间后，最终会使得所有副本达到一致状态。</p><h2 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a><strong>实现方式</strong>：</h2><ul><li><strong>读时修复</strong>：在读取数据时，检测数据是否一致，如果不一致则进行修复。</li><li><strong>写时修复</strong>：在写入数据时，同时更新所有副本，保证数据的一致性。</li><li><strong>异步修复</strong>：定期检测数据是否一致，如果不一致则进行修复。</li></ul><h2 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a><strong>使用场景</strong>：</h2><ul><li><strong>DNS</strong>：域名解析记录在全球各地的DNS服务器上同步，最终达到一致。</li><li><strong>CDN</strong>：内容分发网络将内容缓存到全球各地的节点上，最终达到一致。</li><li><strong>分布式缓存</strong>：缓存数据在多个节点上同步，最终达到一致</li></ul><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在InnoDB中如何实现ACID?</title>
    <link href="/2025/06/22/%E5%9C%A8InnoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ACID/"/>
    <url>/2025/06/22/%E5%9C%A8InnoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ACID/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>大家好啊，我们后端开发中经常会遇到关于数据库设计的问题，那么我们是否真正了解数据库事务处理时的必须具备的四大特性呢？我们今天就以MySQL的默认存储引擎InnoDB来讲讲，它是如何实现ACID的😍</p><h1 id="ACID的定义😵"><a href="#ACID的定义😵" class="headerlink" title="ACID的定义😵"></a>ACID的定义😵</h1><p>ACID是数据库管理系统（DBMS）为了确保事务处理可靠而必须具备的四个基本属性的缩写。这四个属性分别是：</p><ol><li><strong>原子性（Atomicity）</strong> ：指整个数据库操作要么全部完成，要么全部不进行。如果在操作过程中发生了错误，那么所有已经执行的操作都会被回滚到操作前的状态，就像这些操作从未发生过一样。</li><li><strong>一致性（Consistency）</strong> ：确保数据库从一个一致状态转换到另一个一致状态。这意味着事务必须将数据库从一种有效状态带到另一种有效状态，不能违反任何完整性约束条件。</li><li><strong>隔离性（Isolation）</strong> ：多个事务并发执行时，每个事务之间应该是相互隔离的，即一个事务的执行不应该影响其他事务的执行。不同的隔离级别提供了不同程度的事务间可见性的控制。</li><li><strong>持久性（Durability）</strong> ：一旦一个事务被提交，它对数据库所做的更改就是永久性的，即使系统出现故障也不会丢失。</li></ol><p>上面的官方表述是不是没有理解到位呢？我们往下仔细再看看，你肯定可以理解的👌</p><h1 id="InnoDB实现原子性😯"><a href="#InnoDB实现原子性😯" class="headerlink" title="InnoDB实现原子性😯"></a>InnoDB实现原子性😯</h1><p>原子性，为什么是原子性呢？</p><p>我们学过物理都知道，原子是物质的基本构成单位，尽管原子在物理世界中本身可以再进行拆分，但我们在大部分化学反应和物理反应都将其视为最基本的单位，通俗的来说，也就是不可拆分的一步。我们可以将数据库事务视作为“不可拆分”的一步，里面的操作要么全部完成，要么全部不进行！这就是为什么叫做原子性的原因。</p><p>那么InnoDB是如何实现原子性的呢？通过事务日志（redo log和undo log）来实现。当一个事务开始时，所有的修改首先记录在redo log中，并且使用缓冲池（Buffer Pool）来暂存数据页的修改。如果事务失败或中途需要回滚，可以通过undo log恢复到事务开始之前的状态；而当事务成功提交后，即便系统崩溃，重启时也可以根据redo log重做未持久化的修改，从而保证了事务的原子性。</p><h1 id="InnoDB实现隔离性😶‍🌫️"><a href="#InnoDB实现隔离性😶‍🌫️" class="headerlink" title="InnoDB实现隔离性😶‍🌫️"></a>InnoDB实现隔离性😶‍🌫️</h1><p>为什么是隔离性呢？数据库不是一个整体吗？有这个疑问的小伙伴，要认真看看了。MySQL是支持多个客户端同时连接数据库的，那么这样就带来了并发性问题，如果多个连接对同一份数据读，多个事务直接不是各自一份空间（隔离）那岂不是会乱套了？（比如另一个事务读到了一个事务未提交的数据，但是该事务回滚了，数据更改被取消了，另一个事务读到的就是脏数据）。所以InnoDB实现隔离性，防止出现脏读，不可重复读等问题</p><p>InnoDB默认提供的是可重复读（Repeatable Read）级别的隔离性，这是通过多版本并发控制（MVCC, Multi-Version Concurrency Control）技术实现的。MVCC允许查询操作读取事务开始时的数据快照，而不是锁定行，从而减少阻塞并提高并发性能。对于更高要求的隔离级别，如序列化（Serializable），则会采用锁机制来防止幻读等问题。</p><p>可重复读，是在事务开始时读取一份快照（Read View），在这个事务进程中，始终使用的是这份快照，这样就可以保证每个事务都是独立的，每个事务内读到的数据都是一致的，是可重复读的。</p><h1 id="InnoDB实现持久性🤩"><a href="#InnoDB实现持久性🤩" class="headerlink" title="InnoDB实现持久性🤩"></a>InnoDB实现持久性🤩</h1><p>事务一旦提交，就会产生更改，即使系统突然宕机，已经提交的数据也不会丢失，这就是持久性。</p><p>一旦事务被提交，其对数据库的改变就会被写入磁盘上的数据文件，以确保即使发生系统故障，已提交的更改也不会丢失。InnoDB利用redo log来快速记录已完成但尚未写入数据文件的事务修改，在系统恢复期间可以依据redo log重新应用这些修改，从而保障了事务的持久性</p><h1 id="InnoDB实现一致性😉"><a href="#InnoDB实现一致性😉" class="headerlink" title="InnoDB实现一致性😉"></a>InnoDB实现一致性😉</h1><p>举个简单的例子，如果一个银行账户转账事务从账户A转出100元到账户B，在这个事务提交之前，账户A的钱减少了而账户B的钱尚未增加，这将导致数据库暂时处于不一致状态。一致性确保了这种情况不会出现给其他事务看到，并且一旦事务完成，两个账户的余额都会更新为最终正确且合法的状态。在事务开始之前和结束之后，数据库的完整性约束没有被违反，确保数据处于一致的有效状态。这就是一致性。</p><p>InnoDB通过支持外键、检查约束等机制来帮助维护数据的一致性。此外，原子性和隔离性的正确实现也是保持数据库一致性的关键因素。一致性也都是依靠其他三个特性才可以实现的。</p><h1 id="面试🥲"><a href="#面试🥲" class="headerlink" title="面试🥲"></a>面试🥲</h1><p>这是今年暑期某大厂后端面试题之一，要求面试者要理解数据库的四大特性，并通过简短简洁的例子加以说明。相信这篇文章能带给你收获，如果有所收获请点赞加收藏，这是对笔者更新的最大鼓励！！！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次关于Nacos配置中心问题记录与解决</title>
    <link href="/2025/06/22/%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ENacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <url>/2025/06/22/%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ENacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="引言😫"><a href="#引言😫" class="headerlink" title="引言😫"></a>引言😫</h1><p>笔者最近在魔改自己的组件项目，于是想到了引入Nacos来作为自己的配置中心，但是在写好相应的代码后出现了问题，后面会详细叙述</p><h1 id="环境介绍😪"><a href="#环境介绍😪" class="headerlink" title="环境介绍😪"></a>环境介绍😪</h1><p>接下来先来介绍笔者的项目环境</p><ul><li>SpringBoot：2.7.12</li><li>jdk：17</li><li>nacos：2.5.1</li><li>spring-cloud-starter-alibaba-nacos-config：2021.0.6.0</li><li>snakeyaml：1.30</li></ul><p>以下是相应的pom文件配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>    &lt;version&gt;2021.0.6.0&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.yaml&lt;/groupId&gt;<br>    &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;<br>    &lt;version&gt;1.30&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>为什么选用nacos2.5.1，因为官方文档介绍他是稳定生产版本，那么应该可以向下兼容。</p><p>为什么选用spring-cloud-starter-alibaba-nacos-config：2021.0.6.0，因为为了匹配笔者的springBoot版本。</p><h1 id="问题介绍🥹"><a href="#问题介绍🥹" class="headerlink" title="问题介绍🥹"></a>问题介绍🥹</h1><p>当笔者编写完相应代码时，进行测试时，发现无法启动应用。相应的有主要两个报错。</p><p>ps：这两个报错不是一起出现的，笔者只是将他们合在一起讲解。</p><p>报错一：java.lang.IllegalStateException:<strong>Unable to load config data from nacos</strong></p><p>报错二：DEBUG org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter - Application failed to start due to an exception org.springframework.cloud.commons.ConfigDataMissingEnvironmentPostProcessor$ImportException: <strong>No spring.config.import set</strong></p><h1 id="问题分析🫨"><a href="#问题分析🫨" class="headerlink" title="问题分析🫨"></a>问题分析🫨</h1><h2 id="报错一"><a href="#报错一" class="headerlink" title="报错一"></a>报错一</h2><p>报错一的意思大概就是说：这个错误是 Spring Boot 在尝试加载 Nacos 配置时，<strong>无法识别配置文件的格式（即 <code>file-extension</code>）</strong> ，或者没有正确指定配置源类型</p><p>笔者然后在<strong>bootstrap.yml</strong>文件这样配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">a00510c4-c973-4179-961e-dd500a1c350d</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br></code></pre></td></tr></table></figure><p>主要是添加了file-extension: yaml，文件识别为yaml格式</p><p>笔者将maven进行clean + install之后还是不行，报错依然是报错一</p><h2 id="报错二"><a href="#报错二" class="headerlink" title="报错二"></a>报错二</h2><p>报错二的意思大概就是Spring Boot 2.4 开始，引入了新的外部配置加载机制（<code>ConfigData</code>），SpringBoot要显式的声明从哪里导入配置，比如nacos。</p><p>然后笔者在<strong>bootstrap.yml</strong>文件这样进行配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span> <br>    <span class="hljs-attr">import:</span> <span class="hljs-bullet">-</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">a00510c4-c973-4179-961e-dd500a1c350d</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br></code></pre></td></tr></table></figure><p>结果还是报错二</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>笔者由这两个报错联想到，这两个报错都有个共同点，就是无法识别配置源的信息，既然这样，那么我直接禁用检查，先让应用启动跑起来看看有没有其他报错不就行了吗？</p><h1 id="解决😈"><a href="#解决😈" class="headerlink" title="解决😈"></a>解决😈</h1><p>按照上述思路，笔者打算一招就解决两个报错，试试就试试！！</p><p>bootstrap.yml如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">a00510c4-c973-4179-961e-dd500a1c350d</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br></code></pre></td></tr></table></figure><p>application.yml如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dynamic-thread-pool-test-app</span><br><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>application-dev.yml如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8093</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">a00510c4-c973-4179-961e-dd500a1c350d</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>        <span class="hljs-attr">data-id:</span> <span class="hljs-string">dynamic-thread-pool-test-app-dev.yaml</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>        <span class="hljs-attr">import-check:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">extension-configs:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">data-id:</span> <span class="hljs-string">dynamic-thread-pool-test-app-dev.yaml</span><br>            <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>            <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>主要解决问题的点在于使用了import-check: enabled: false，禁用了检查。</p><p>笔者然后顺利了启动应用进行测试，应用的新功能都按照预期进行，没有其他bug。</p><h1 id="反思🥰"><a href="#反思🥰" class="headerlink" title="反思🥰"></a>反思🥰</h1><p>笔者觉得应该是boot的版本和nacos的版本有点冲突导致的，或者是笔者还没有真正的找到问题所在，只能使用停止检查的手段，如果你也有这样的困惑，不妨也试试我的方法。也请有懂的佬来看看是怎么回事，评论区见。</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这是笔者的一次报错解决，如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>Nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式解决后端接口慢如何排查优化</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%85%A2%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E4%BC%98%E5%8C%96/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%85%A2%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>自己负责的后端应用模块上线后，经客户反馈接口调用慢，也就是性能出了问题。但是整个业务组的后端接口如此之多，怎么排查了解是哪个接口出了问题，怎么优化接口性能呢？今天就和大家一起来探讨一下。</p><h1 id="排查接口😫"><a href="#排查接口😫" class="headerlink" title="排查接口😫"></a>排查接口😫</h1><h2 id="监控与日志"><a href="#监控与日志" class="headerlink" title="监控与日志"></a>监控与日志</h2><ul><li><p><strong>应用性能监控 (APM) 工具：</strong>  使用 APM 工具（如 skywalking）可以全面监控应用程序的性能，包括：</p><ul><li><strong>响应时间：</strong>  接口的平均响应时间、最大响应时间等。</li><li><strong>吞吐量：</strong>  每秒请求数 (RPS) 或每分钟请求数 (RPM)。</li><li><strong>错误率：</strong>  接口的错误率，例如 500 错误。</li><li><strong>资源利用率：</strong>  CPU 使用率、内存使用率、磁盘 I&#x2F;O、网络 I&#x2F;O 等。</li><li><strong>调用链追踪：</strong>  跟踪请求从进入到返回的完整调用链，找出瓶颈所在。</li></ul></li><li><p><strong>日志：</strong></p><ul><li><strong>访问日志：</strong>  记录每个请求的详细信息，包括请求时间、客户端 IP、请求路径、响应时间、状态码等。</li><li><strong>应用日志：</strong>  记录应用程序的运行状态、错误信息、调试信息等。</li><li><strong>GC 日志：</strong>  记录垃圾回收的详细信息，用于分析垃圾回收是否是性能瓶颈。</li></ul></li><li><p><strong>网络排查：</strong></p><ul><li>如果接口涉及跨服务调用，检查网络延迟情况。可能需要使用ping、traceroute等工具来诊断网络连接的质量。</li><li>考虑使用CDN加速静态资源加载，减轻服务器压力</li></ul></li></ul><h2 id="分析监控与日志"><a href="#分析监控与日志" class="headerlink" title="分析监控与日志"></a>分析监控与日志</h2><ol><li><p><strong>确定问题范围：</strong></p><ul><li>是所有接口都慢，还是只有个别接口慢？</li><li>是持续性慢，还是偶发性慢？</li><li>是特定用户慢，还是所有用户都慢？</li></ul></li><li><p><strong>分析监控数据：</strong></p><ul><li>查看 APM 工具的监控数据，找出响应时间长的接口。</li><li>分析访问日志，找出慢请求的模式。</li><li>分析应用日志，查看是否有错误或异常发生。</li><li>分析 GC 日志，查看垃圾回收是否频繁或耗时过长。</li></ul></li><li><p><strong>调用链分析：</strong></p><ul><li><p>使用 APM 工具的调用链追踪功能，跟踪慢请求的调用链，找出瓶颈所在。</p></li><li><p>常见的瓶颈包括：</p><ul><li><strong>数据库查询：</strong>  查询语句慢、索引缺失、数据量过大等。</li><li><strong>远程调用：</strong>  调用第三方服务慢、网络延迟高等。</li><li><strong>I&#x2F;O 操作：</strong>  磁盘 I&#x2F;O 慢、网络 I&#x2F;O 慢等。</li><li><strong>代码逻辑：</strong>  复杂的计算、死循环等。</li></ul></li></ul></li></ol><h1 id="优化接口👻"><a href="#优化接口👻" class="headerlink" title="优化接口👻"></a>优化接口👻</h1><p>通过以上方法我们可以找到对应的慢接口，接下来就要根据其具体情况来加以优化。</p><p><strong>1.数据库优化：</strong></p><ul><li>分析SQL语句：使用 <code>EXPLAIN</code> 命令分析 SQL 语句的执行计划，找出慢查询的原因。</li><li>添加索引：如果通过分析该SQL语句的执行计划，发现无索引，就为经常查询的字段添加索引</li><li>防止索引失效：如果SQL语句没有遵循索引使用的相关规则，就会导致索引失效，例如使用了左模糊或者左右模糊查询，没有遵循最左匹配原则等</li><li>优化SQL语句：通过避免使用 <code>SELECT *</code>，只查询需要的字段；避免在 <code>WHERE</code> 子句中使用函数；使用批量操作代替单条操作等来提高SQL效率。</li><li>数据库连接池：确保数据库连接池配置合理，避免连接数不足或过多。</li></ul><p> <strong>2. 远程调用优化：</strong></p><ul><li><strong>超时设置：</strong>  设置合理的超时时间，避免长时间等待。</li><li><strong>重试机制：</strong>  实现重试机制，处理偶发性调用失败。</li><li><strong>异步调用：</strong>  使用异步调用，避免阻塞主线程。</li><li><strong>串行改并行</strong>  查询从串行请求变成并行请求，查询效率提高。</li><li><strong>熔断机制：</strong>  实现熔断机制，防止雪崩效应。</li></ul><p> <strong>3. I&#x2F;O 优化：</strong></p><ul><li><strong>使用缓存：</strong>  将热点数据缓存在内存中，减少 I&#x2F;O 操作。</li><li><strong>缓存预热：</strong>  将可能要用的数据提前预热到缓存中，避免实时计算耗费时间。</li><li><strong>批量读写：</strong>  使用批量读写操作，减少 I&#x2F;O 次数。</li><li><strong>异步 I&#x2F;O：</strong>  使用异步 I&#x2F;O 操作，避免阻塞主线程。</li></ul><p> <strong>4.代码优化：</strong></p><ul><li><strong>算法优化：</strong>  选择合适的算法，降低时间复杂度。</li><li><strong>数据结构优化：</strong>  选择合适的数据结构，提高数据访问效率。</li><li><strong>并发优化：</strong>  使用多线程或协程，提高并发处理能力。</li><li><strong>避免死锁：</strong>  检查代码中是否存在死锁的可能。</li><li><strong>锁的粒度：</strong>  检查代码中锁的粒度是否过大，如果过大则减少锁的粒度。</li><li><strong>使用池化：</strong>  引入池化的思想，数据库连接池，线程池等，避免频繁创建销毁连接而导致的时间与资源损耗。</li></ul><p> <strong>5.资源：</strong></p><ul><li><strong>IO连接：</strong> 检查是不是太多IO连接未关闭导致的接口耗时增加，连接要及时关闭。</li><li><strong>线程吃紧：</strong> 如果线程数已经满了，其他多余请求自然只能等待，在高并发的场景下只能限流来保证系统正常运行。</li><li><strong>GC问题：</strong> 如果JVM内存吃紧就会导致FullGC的情况，整个应用都会变慢。</li><li><strong>申请资源：</strong> 巧妇难为无米之炊，如果要面临很大的并发场景，没有合适的机器资源怎么做都会多余，向你的Boss申请合适的服务器资源！</li></ul><h1 id="示例😉"><a href="#示例😉" class="headerlink" title="示例😉"></a>示例😉</h1><p>假设你发现一个查询用户信息的接口很慢，你可以按照以下步骤排查：</p><ol><li><strong>监控：</strong>  使用 APM 工具监控该接口的响应时间，发现平均响应时间超过 1 秒。</li><li><strong>分析：</strong>  分析访问日志，发现该接口的慢请求都集中在晚上 8 点到 10 点。</li><li><strong>调用链分析：</strong>  使用 APM 工具跟踪该接口的调用链，发现瓶颈在数据库查询。</li><li><strong>定位：</strong>  使用 <code>EXPLAIN</code> 命令分析 SQL 语句，发现没有使用索引。</li><li><strong>解决：</strong>  为 <code>user_id</code> 字段添加索引，重新部署应用程序。</li><li><strong>验证：</strong>  使用 APM 工具监控该接口的响应时间，发现平均响应时间降到 100 毫秒以下</li></ol><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这是后端开发中常遇到的问题，也是面试中常问的问题。如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>后端开发问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>后端开发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式排查优化慢SQL</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E6%8E%92%E6%9F%A5%E4%BC%98%E5%8C%96%E6%85%A2SQL/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E6%8E%92%E6%9F%A5%E4%BC%98%E5%8C%96%E6%85%A2SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在我们后端日常开发测试中，常常会遇到一个SQL语句查询过慢而导致的整体接口响应速度变慢，用户体验不好。这时候如果确认接口变慢是因为慢SQL的原因，我们就需要对慢SQL进行排查优化。</p><h1 id="识别慢SQL😵"><a href="#识别慢SQL😵" class="headerlink" title="识别慢SQL😵"></a>识别慢SQL😵</h1><p>一个项目的SQL语句往往庞大而冗杂，那我们想要知道是哪几个SQL导致我们对应的接口变慢，该如何排查呢？</p><p>一般常用以下方法进行排查</p><h2 id="慢日志查询"><a href="#慢日志查询" class="headerlink" title="慢日志查询"></a>慢日志查询</h2><p>开启数据库的慢查询日志功能，记录执行时间超过指定阈值的 SQL 语句。这是最常用的方法，可以帮助你快速找到需要优化的 SQL。</p><ul><li><strong>MySQL:</strong>  设置 <code>long_query_time</code> 参数，并开启 <code>slow_query_log</code>。</li><li><strong>PostgreSQL:</strong>  设置 <code>log_min_duration_statement</code> 参数。</li><li><strong>SQL Server:</strong>  使用 SQL Server Profiler 或 Extended Events 监控执行时间长的查询</li></ul><p>以MySQL为例，如何进行慢日志查询呢？</p><h3 id="查看当前配置"><a href="#查看当前配置" class="headerlink" title="查看当前配置"></a><strong>查看当前配置</strong></h3><p>首先，你需要查看当前的 <code>long_query_time</code> 和 <code>slow_query_log</code> 的配置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;long_query_time&#x27;</span>; <br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log_file&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>long_query_time</code>：慢查询的阈值，单位为秒。默认值通常是 10 秒。</li><li><code>slow_query_log</code>：是否开启慢查询日志。<code>ON</code> 表示开启，<code>OFF</code> 表示关闭。</li><li><code>slow_query_log_file</code>：慢查询日志文件的路径</li></ul><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a><strong>修改配置</strong></h3><p>你可以通过以下两种方式修改配置：</p><ul><li><p><strong>修改 MySQL 配置文件 (my.cnf 或 my.ini)：</strong></p><ol><li>找到 MySQL 的配置文件。在 Linux 系统中，通常位于 <code>/etc/my.cnf</code> 或 <code>/etc/mysql/my.cnf</code>。在 Windows 系统中，通常位于 MySQL 安装目录下的 <code>my.ini</code> 文件。</li><li>使用文本编辑器打开配置文件，找到 <code>[mysqld]</code> 部分（如果没有，则添加该部分）。</li><li>在 <code>[mysqld]</code> 部分添加或修改以下配置：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">long_query_time</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">slow_query_log</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log<br><span class="hljs-attr">log_output</span> = FILE<br></code></pre></td></tr></table></figure><ul><li><p><code>long_query_time</code>：设置为你希望的慢查询阈值，例如 1 秒。</p></li><li><p><code>slow_query_log</code>：设置为 <code>1</code>，表示开启慢查询日志。</p></li><li><p><code>slow_query_log_file</code>：设置慢查询日志文件的路径。请确保 MySQL 用户对该目录有写入权限。</p></li><li><p><code>log_output</code>：设置日志输出方式为文件。</p></li></ul><ol start="4"><li>保存配置文件，并重启 MySQL 服务，使配置生效。</li></ol></li><li><p><strong>使用 SET GLOBAL 命令动态修改：</strong></p><ol><li>使用具有 <code>SUPER</code> 权限的 MySQL 用户登录。</li><li>执行以下 SQL 语句：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> long_query_time <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ON&#x27;</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log_file <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;/var/log/mysql/mysql-slow.log&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>这些设置会立即生效，但 MySQL 服务重启后会失效。如果希望永久生效，仍然需要修改配置文件。</li></ul></li></ul><h3 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a><strong>配置生效</strong></h3><ul><li><p><strong>如果修改了配置文件，需要重启 MySQL 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart mysql  <span class="hljs-comment"># Linux (systemd)</span><br><span class="hljs-built_in">sudo</span> service mysql restart    <span class="hljs-comment"># Linux (SysVinit)</span><br>net stop mysql                <span class="hljs-comment"># Windows</span><br>net start mysql               <span class="hljs-comment"># Windows</span><br></code></pre></td></tr></table></figure></li><li><p><strong>如果使用了 SET GLOBAL 命令，不需要重启 MySQL 服务，配置会立即生效。</strong></p></li></ul><h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a><strong>验证配置</strong></h3><p>重新执行以下 SQL 语句，确认配置是否生效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;long_query_time&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log_file&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="分析慢查询日志"><a href="#分析慢查询日志" class="headerlink" title="分析慢查询日志"></a><strong>分析慢查询日志</strong></h3><ul><li><p>慢查询日志会记录执行时间超过 <code>long_query_time</code> 的 SQL 语句。</p></li><li><p>你可以使用文本编辑器打开慢查询日志文件，查看慢 SQL 语句。</p></li><li><p>也可以使用 <code>mysqldumpslow</code> 工具分析慢查询日志，找出执行频率最高的慢 SQL 语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqldumpslow -s t -a /var/log/mysql/mysql-slow.log<br></code></pre></td></tr></table></figure><ul><li><code>-s t</code>：按照查询时间排序。</li><li><code>-a</code>：不将数字和字符串抽象化。</li></ul></li></ul><p><strong>注意事项</strong></p><ul><li><code>long_query_time</code> 的值应该根据你的应用场景进行调整。如果你的应用对响应时间要求很高，可以将 <code>long_query_time</code> 设置为更小的值。</li><li>开启慢查询日志会增加 MySQL 的 I&#x2F;O 负担，因此不建议在生产环境中长时间开启。可以在需要排查问题时临时开启，问题解决后及时关闭</li></ul><h1 id="分析慢SQL😯"><a href="#分析慢SQL😯" class="headerlink" title="分析慢SQL😯"></a>分析慢SQL😯</h1><p>当我们通过慢SQL日志了解到了哪几个SQL语句是慢SQL之后，就需要对其进行分析。以MySQL为例</p><h2 id="获取执行计划："><a href="#获取执行计划：" class="headerlink" title="获取执行计划："></a><strong>获取执行计划：</strong></h2><p>使用 <code>EXPLAIN</code> 命令，查看 SQL 语句的执行计划。执行计划可以告诉你数据库是如何执行 SQL 语句的，包括使用了哪些索引、表连接方式等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <span class="hljs-keyword">AND</span> order_date <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2023-01-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2023-01-31&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="分析执行计划："><a href="#分析执行计划：" class="headerlink" title="分析执行计划："></a><strong>分析执行计划：</strong></h2><p>获取执行计划之后，我们需要通过几个核心参数了解具体SQL语句执行情况。</p><ul><li><p>possible_keys: 该SQL语句可能会用到的索引</p></li><li><p>key: 该SQL语句实际上用到的索引</p></li><li><p>type: 执行该SQL语句的扫描方式</p></li></ul><p>其中type我们尤其需要注意，扫描方式效率从低到高依次为ALL，index，range，ref，eq_ref,const</p><p>这个参数最好在range及以上，效率越高越好</p><h1 id="优化慢SQL🤩"><a href="#优化慢SQL🤩" class="headerlink" title="优化慢SQL🤩"></a>优化慢SQL🤩</h1><ul><li><p><strong>索引优化：</strong></p><ul><li><strong>添加索引：</strong>  为经常用于查询的字段添加索引。</li><li><strong>复合索引：</strong>  考虑使用复合索引，可以提高多字段查询的性能。</li><li><strong>覆盖索引：</strong>  尽量使用覆盖索引，避免回表查询。</li><li><strong>删除无用索引：</strong>  删除不再使用的索引，减少索引维护的开销。</li><li><strong>防止索引失效：</strong> 正确使用索引，防止索引失效</li></ul></li><li><p><strong>SQL 语句优化：</strong></p><ul><li><strong>避免使用 <code>SELECT *</code>：</strong>  只查询需要的字段，减少 I&#x2F;O 开销。</li><li><strong>避免在 <code>WHERE</code> 子句中使用函数：</strong>  函数会导致索引失效。</li><li><strong>使用 <code>JOIN</code> 代替子查询：</strong>  <code>JOIN</code> 通常比子查询更有效率。</li><li><strong>优化 <code>LIKE</code> 查询：</strong>  避免使用 <code>LIKE &#39;%keyword%&#39;</code>，可以使用全文索引或倒排索引。</li><li><strong>使用批量操作代替单条操作：</strong>  批量插入、更新、删除操作可以减少网络开销。</li><li><strong>避免在循环中执行 SQL 语句：</strong>  将循环中的 SQL 语句合并成一条 SQL 语句。</li></ul></li><li><p><strong>数据库配置优化：</strong></p><ul><li><strong>调整缓冲区大小：</strong>  调整数据库的缓冲区大小，可以提高数据访问速度。</li><li><strong>调整连接池大小：</strong>  调整数据库连接池的大小，可以提高并发处理能力。</li><li><strong>优化操作系统参数：</strong>  优化操作系统的 TCP 参数、I&#x2F;O 参数等，可以提高数据库的整体性能。</li></ul></li></ul><h1 id="示例😍"><a href="#示例😍" class="headerlink" title="示例😍"></a>示例😍</h1><p>给出一个用复合索引来优化慢SQL的例子：</p><p>假设你发现以下 SQL 语句执行很慢</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <span class="hljs-keyword">AND</span> order_date <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2023-01-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2023-01-31&#x27;</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>获取执行计划：</strong>  使用 <code>EXPLAIN</code> 命令查看执行计划，发现没有使用索引。</li><li><strong>分析执行计划：</strong>  发现全表扫描了 <code>orders</code> 表。</li><li><strong>优化：</strong>  为 <code>customer_id</code> 和 <code>order_date</code> 字段添加复合索引：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_customer_order_date <span class="hljs-keyword">ON</span> orders (customer_id, order_date);<br></code></pre></td></tr></table></figure><p><strong>验证：</strong>  再次执行 SQL 语句，并查看执行计划，发现使用了索引，执行速度明显提高</p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNpVk8tu2kAUhl8FzSqVAJmxScCLSgnkQgKoiy6qGhZW7QSkgJFrpLYWEioppUpJSJMQ2qRBRaJkQ6h6SXOB8jKesVn1FTp4gLhezZn5zv__R57RwTNFkgEPtlQxl3I9DieyLvItCqhfRJ3dpMvjeehamkO1nnl0gd-0cLNt9Vr4pI2GJw8ou2QzIR03eqj2FZ-9m2HW5Tc0OP7bbxYoGSKki2B2Q1iw9n6j_fqMTjogImRDy4J5d4g_NydnYXtzZc4YDEmc5SePoouROKqU8Xlt6vgFVT5Mgq3Y9OokGO0xbsuoVhkVX5ufdsyfLdR3xFt1Oq8JRr-B3tcpZF3-IdJJBzcdI6JT53HO8x1qRRzMWvleOOIUXhdGb6tjlAbuddF-O-ngpsIbOi52rNLAuKsa11Wih0s_7iXXKEOLdWex4RSJClaxZH08oMOb_UPUbeCzW1S5wpW6NTw1rou426aTJh3907AxAf_atXrH6OZqVLowB98nUJSe0iJmF3HBPD3Aex2aGh_dEPkJHf__XwI3uW1pCfCampfdICOrGXFcAn2MJ4CWkjNyAvBkKcmbYn5bS4BEtkDacmL2qaJkpp2qkt9KAX5T3H5OqnxOEjU5nBbJVc7MdlU5K8lqSMlnNcD7fD6_rQJ4HbwAPIScl1mAkOEWIMtwnBu8BLwHBr1BBkL_gj_IcgwD2fmCG7yyfX1eNsAGGR8HOQYG_Gxg3g1kKa0paow-I_s1Ff4BzyFumg"><img src="https://i-blog.csdnimg.cn/img_convert/9ea65d6c1c5e7fca49ac252a8f5b1a98.jpeg"></a></p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这是后端面试常问的问题，建议各位结合自己的项目进行回答，面试官问你的优化方法也可以有更多的思路。如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式解决缓存与数据库数据一致性</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>后端面试的时候，面试官常问如何保证缓存与数据库数据的一致性，很多同学都是东答一句西答一句，很少有回答较完整的，那么今天我们就一起总结一下，如何全面地回答这个问题。</p><h1 id="Cache-Aside-Pattern🥱"><a href="#Cache-Aside-Pattern🥱" class="headerlink" title="Cache Aside Pattern🥱"></a>Cache Aside Pattern🥱</h1><p>即<strong>旁路缓存模式</strong></p><ul><li>当读取数据时，首先检查缓存中是否存在所需的数据。如果存在，则直接返回；如果不存在，则从数据库中读取数据，更新到缓存后再返回给客户端。</li><li>当写入或更新数据时，先更新数据库，然后使缓存中的旧数据失效（即删除缓存中的对应数据）。这种方式避免了直接更新缓存可能带来的复杂性和潜在问题。</li></ul><p>简单来说，就是大家常听到的先更新数据库，后删除缓存，但是这种方案仍有较小概率出现脏缓存问题（并发前提下）</p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNptkltL40AUx79KOE8Kbcm1bfIgqPW67JtPJj6EzWjLbpMSU9i1LYgPEkTFpbq74rKyXkAU0woLLl7ol3Em8Vs4zUwV0XkY5pz5_c85f2Ya8MlzEBiw5Nu1sjBXslyBrlETR0ckvI4vOknnmlytLQjZ7Egz6dyysCmMDZHjVXJ4Gt-18eWvYSYbSymWwt_vH_5fNoVxM-nt4oM_LEv2umQrWniLk9_nA0XJpHWTzhFj8U2b46U-LkyYuLvOr2iXtTMcdlkJjk2k2CRvy8j4dv_ZEMfYPvW-Uby-PzA6PRQf_CPbp0nUe_wZPc_EHU-nzWbMh_set31yRfZC3mMmvZ01479REp0QWudHF0ebJNzhwGwKfBjMGu7gjUPc3sI3u68mhgx9n4oDRuDXUQaqyK_a_RAa_TIWBGVURRYY9OjY_mcLLLdFNTXbnfe86kDme_WlMhiL9pdlGtVrjh2gUsWmL_-CINdB_rhXdwMw9LQCGA34CoasKzlNFUVVkXRJ1_KimoFvYGQlTc2pmlQsaIqo5OViodjKwEraVcrJeZ2mNFktFEW5oFAJciqB539kfy79eq0nJYwiXw"><img src="https://i-blog.csdnimg.cn/img_convert/0ef3560f82c0cc2098f9a45fce5982e6.jpeg"></a></p><h1 id="延迟双删优化😵"><a href="#延迟双删优化😵" class="headerlink" title="延迟双删优化😵"></a>延迟双删优化😵</h1><p>即在旁路缓存的基础上，优化成，先删除缓存，再更新数据库，最后延迟合适的时间再删除一遍缓存，防止脏缓存出现。延迟时间需要根据业务逻辑的执行时间和读取数据库及写入缓存的时间来评估，以确保在延迟时间内，其他请求可以完成数据库读取和缓存写入操作。</p><p>但延迟双删也有其缺点：</p><ul><li><strong>并非强一致性</strong>：即使使用延迟双删，仍然不能完全避免Redis脏数据的问题，只能缓解。要完全解决，可能需要使用同步锁或在业务逻辑层进行处理 </li><li><strong>操作失败处理</strong>：删除缓存操作有可能会失败，如果第二次删除缓存失败，可以考虑重试机制或使用消息队列进行异步同步</li></ul><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNptk1tPGkEUx78KmcSEJki4CuxDkyraWvWtTwUeNmWrpgXMFpK2aoJEERG8VMELpFTFSlt3gagoiPphumdmefIrdPYibdV92MzO_P7nf86ZPdPoTSTIIQaN8-zUhOGV1x820OeZD8R9nDonv6qwui6fnUNyR66e43oiYOjtfWroN3a-52EhJV3dkPYGCNtQruNc6omm7leZAR8RluB6gZQEvJvAW43O1mlAAwZUwGvEhVOcr-FcDWdFaG3ocq96OqjLpYs4Fs_-kw-qwJCRHB9LrQw-3ns8jSEVe-4je6IsljUvEDM4tQbNhnyzCYWvyjpdgo0stDbJ5U63aGqkxXhxvxFy9fLfRgwb8UEclw41e914WDma0TNav5IuhBnDS5_mqO1qJQce4rj4804x4qNx5ep-tz06PqIaj_qgltSPqEuiAqmaFkLHRlVsTLfVyHslKpj27ukx4JNKZzF9297FQhkK11DPkXJLaiXhkvaqBKsZSH0jQp7kDsnuPBYOaFfx2RypLN-2M5A9efR_oEdkvgFrK_cuWpE0G1CsPLxiCkMy-_BOf8cT3VTlmx1ylMX5Jj7J4eISpH9IrRVYXIXaOtms07Uu_JLpOkrNZTV4BguHekXVtrx4qtSiMtJFlqZBd3D8qLMldva3qSMy0bmYDCImysc4EwpxfIhVPtG0kosfRSe4EOdHDF0GWf6dH_nDs1QzxYZfRyKhOxkfiY1PIOYt-_4D_YpNBdko551k6cT9RbhwkOMHIrFwFDEeNQJiptFHxNg8drPTYbE47FaP1ePsszhM6BNieq1Oh9nhtLpdTrvF3mdzu9yzJvRZdbWabX0euuW0OVxui81lpxIuOBmN8GParKsjP_sHuSEX1w"><img src="https://i-blog.csdnimg.cn/img_convert/874f29f28702453afccf9499f8143438.jpeg"></a></p><h1 id="分布式锁更新缓存😯"><a href="#分布式锁更新缓存😯" class="headerlink" title="分布式锁更新缓存😯"></a>分布式锁更新缓存😯</h1><p>谈到同步问题必定想到锁。但是有些同学会想到用synchronized，Reentrantlock等Java提供的锁机制来实现更新缓存，这就是某些同学的知识盲区了，对分布式锁理解不够到位。像 <code>synchronized</code> 和<code>ReentrantLock</code> 这样的锁机制是Java语言层面提供的同步工具，主要用于在同一JVM实例内的线程间进行同步控制，<strong>在分布式系统中</strong>，服务通常部署在多台机器上，每台机器都有自己的JVM实例。因此，需要一种能够在不同JVM之间进行协调的锁机制，<strong>分布式锁</strong>便是为此而生的。</p><p>“没有什么是加一层中间层解决不了的，如果有就多加一层”，多个客户端通过网络向这个中间层发起请求。我们可以使用Redis或者ZooKeeper来实现分布式锁这一功能。以Redis为例子，用Redis的SetNx功能来做分布式锁（最好带过期时间，防止系统无响应问题），当一个写线程来更新数据库，便尝试获得该独占锁，获得锁成功之后，其他线程其他试图更新相同数据的服务实例将被阻塞，直到锁被释放。更新数据库和更新缓存是由同一个线程来进行的，这样就保证了<strong>强一致性</strong>，但是也带来了<strong>性能较差</strong>的问题。</p><p>为什么是更新数据库，也一起更新缓存，而不是由其他线程来读来重建缓存？即使采用“删除缓存 + 等待其他线程读取重建缓存”的策略，仍然存在产生脏数据的可能性。</p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNp1lFtPGkEUx7_KZhKTNkHDVWAfmlRQq7YvTZ-6-EDKVkkFDELSFkjWCwICSoqAF9SagtILiPWGCPhhypndffIrdPai7ov7tLPn__-dmXPObAR9CHhYRKOZoHt-lnrndPkp8rxkoMPBcXqaGhx8QY08g-QeWUGm-Jb1eBcWAn7HnJf1h54r6hFZ5YhAc084KQjrV7BRhOQqtJahsyFuLsYUmUOSRXEyB2sHUcrJ4NSxcJjBhSbONqCdx7vnuNjE-Wy_W55WHE4ZPMooIb6Th_qWGhqVQ2MMf9gQGhVFAI0MoauCMVkwzoiJNbzZ025HFYzLglcMf5PHewfko3aXUDkVzqtRaoLh6ynoxeH6UkxkyelwsijhOssqZUKmTDL4B4cPqnjrBHJHQo_ka-IyB5Vj1fXnkJxTtUwqdSj_Irp-a03czkWpKTVPv8XhxgUuXYqlc8itK27VN6U0QwuBq78ayGtGaDShW8ClKtyWpC1zHCTaD0cbGKDwWY0U5K6zg-sV2O3BaYGvtPvtVZHbEW4T993td2_5zZq2ZtoO8DsrEG_BfhpfLPK19D9u6QEvHhUhnnxiWu46GX7lkpzqqTnRkpQxUTQkRFzEDhsn_ZsqNFIQr0G5qd0UfHucJC0Hjpbwflkq9nKX_52G7JnE7JUIUwImt_H3a-Li60W-UBW5FE7_VDrx0G6eZFmvKqUkZKQjd8XrQXQoGGZ1yMcGfW5piSJSThcKzbI-1oVo8upxBz-5kMsfI555t_99IOC7twUD4ZlZRH90zy2QVXje4w6xTq-b3MJHCev3sEFHIOwPIdouExAdQZ8RbbSbhixmvd5sMtgNdsuw3qxDXxA9aLCYh8wWg81qMelNw0ab1RbToa9yVsOQcdhOPlmMZqtNb7SarDpEmhMKBN8o91_-DcT-A3pMB2c"><img src="https://i-blog.csdnimg.cn/img_convert/81eeea808c15d3aa2fb25410ae41f4e5.jpeg"></a></p><h1 id="MQ逐步更新数据库🤩"><a href="#MQ逐步更新数据库🤩" class="headerlink" title="MQ逐步更新数据库🤩"></a>MQ逐步更新数据库🤩</h1><p>我们可以借助MQ来帮我们实现数据库与缓存之间<strong>最终一致性</strong>。引入一个秒杀场景来方便讲解，当大量请求打到Redis缓存时，我们先用decr + 滑动窗口实现库存在Redis的快速扣减，一旦扣减成功就将相应信息存进MQ，让MQ削峰减流，从而让订阅该消息的消费者通过监听器逐步更新数据库。如果Redis库存已经扣减到0，可以借助MQ发送直接让数据库存更新为0的情况，进一步减少数据库的压力。</p><p>可以借助MQ的事务消息，分布式事务或者本地消息表等方案进一步保证消费者一定会消费到消息，解决消息丢失，消费幂等等问题。</p><p>这种方案性能非常高，而且可以保证最终一致性，但这种方案不适应强一致性的金融等场景，而且也增加了实现难度和维护难度。</p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNqNlGlPGkEYx7_KZhLfoeGUI9FExatKLV5VF2KobNW0guFIbAkJSjmkEbEqtRVrSbGaRgGrRUCqX4YZlm_RYWZaUDHpvtjszvP7P_NcMx4wZ7cKQAfmHZblBW5cb7Jx-OniYckHj9-budbWTq6bR9EjtJOrHH9ABz4xc4XO18wU7CZAD1--jo4K1kVnOX9mFeYcsLgNz_YY00MYvYcuor0MjH2HqeNyMVo5W8dvqZdy9K3HNIchIurlYfZAzOyK0Su4GYfhIMz7YWmzurM66xRctpVZtkUvoft4MZ2Fv3dR4hQmsigXRqsZMXnCmD7C9PNwc6vqW6VWGM4ajMzeT-wDHmahFAkWhWMwcngnygESJVknskG-GoqgnZvGEJnfQQI84SvX2-jg0PzAC0ydi5dHBBrCXjZwumzzcFxMHsHVW5QownCOKYcIOeyhoYk3eMssSvhwQakWnSbRbpYFO0zCTPzAWDkfqX6K0Ro0GOHVz7tGAw9T7yqxICytwXwe-QMw-IttbSDA02aZkK7heAgxwlf2L_HIiLc7cP8LbXs5vyHmLphmhGDPmjmqdZJj7a4XxsjjUYE3AVjIsSzD8Vq1S34mNhJs9P-qMtq0Kr0NxgdVGXu8KmMEGK8nQ5dbWjiDEc-SeFkQfYGq_wSPBrU43S_oaWuwU-_UXh_GCf4fUNnfgrFTosDTaa6TE4Sc5NHXAtpIs-ENBmC6gHAT4lmcNl6vNaHxTNaeSaJ8zleSaTGdokq6H4MEm7UhG3Z817_B0KYYupCij7nKegGlI42x67mOjgckXuvkpviq77N4GzIY6XQzKB-o7ufuJDVFwpq-nzpu6KOSaSKZYWMHs8F7SdNKlPNFKRPMEEFXV7PcgQRfhotWoHM53IIELAmOJUvtF3hqWhNwLQhLggno8KfV4nhlAiabF2uWLbYZu33pr8xhd88vAN1Ly2sn_nMvWy0uQb9owY2vI7i-gqPH7ra5gE5LPACdB6wAnVyraFMppVKlQqaVaVXtUqUEvAG6VplK2aZUyTRqlUKqaJdr1BqvBLwlu8ra5O1avKSSK9UaqVytUEsAvpBddoeBXvDknvf-AbdOw9I"><img src="https://i-blog.csdnimg.cn/img_convert/8b7d010a860cab041dcb6ba1262b7704.jpeg"></a></p><h1 id="binlog-Canal😈"><a href="#binlog-Canal😈" class="headerlink" title="binlog + Canal😈"></a>binlog + Canal😈</h1><p>使用 <code>binlog + Canal</code> 实现 MySQL 和 Redis 数据一致性是一种常见的、相对可靠的方案。其核心思想是：Canal 模拟 MySQL Slave，伪装成 MySQL 的从节点，从 MySQL Master 接收 binlog 日志，然后解析 binlog，将数据变更同步到 Redis。</p><p><strong>工作原理</strong></p><ol><li><p><strong>MySQL 开启 binlog</strong>：</p><ul><li>确保 MySQL 开启了 binlog 功能，并且 binlog 的格式设置为 <code>ROW</code> 模式。这是 Canal 能够正常工作的前提。</li></ul></li><li><p><strong>Canal 模拟 Slave</strong>：</p><ul><li>Canal 伪装成 MySQL 的 Slave 节点，向 MySQL Master 发起连接请求。</li></ul></li><li><p><strong>MySQL Master 推送 binlog</strong>：</p><ul><li>MySQL Master 接收到 Canal 的请求后，会将 binlog 日志推送给 Canal。</li></ul></li><li><p><strong>Canal 解析 binlog</strong>：</p><ul><li><p>Canal 接收到 binlog 日志后，会按照配置规则解析 binlog，提取出数据变更的详细信息，例如：</p><ul><li>哪个数据库的哪个表发生了变更</li><li>变更的类型（INSERT、UPDATE、DELETE）</li><li>变更前后的数据</li></ul></li></ul></li><li><p><strong>Canal 同步数据到 Redis</strong>：</p><ul><li><p>Canal 根据解析出的数据变更信息，将数据同步到 Redis。同步的方式可以根据实际需求进行选择，例如：</p><ul><li><strong>更新缓存</strong>：将变更后的数据更新到 Redis 中。</li><li><strong>删除缓存</strong>：删除 Redis 中对应的数据。</li></ul></li></ul></li><li><p><strong>应用程序读取 Redis</strong>：</p><ul><li>应用程序从 Redis 中读取数据，如果 Redis 中没有数据，则从 MySQL 中读取，并将数据写入 Redis。</li></ul></li></ol><p>这种方案也有其优缺点：</p><p><strong>优点</strong></p><ul><li><strong>实时性高</strong>：Canal 能够实时地将 MySQL 的数据变更同步到 Redis，保证了数据的一致性。</li><li><strong>可靠性高</strong>：Canal 模拟 MySQL Slave，能够可靠地接收 binlog 日志，避免了数据丢失。</li><li><strong>可扩展性强</strong>：Canal 支持多种数据同步方式，可以根据实际需求进行选择。</li><li><strong>解耦</strong>：将数据同步的逻辑从应用程序中分离出来，降低了应用程序的复杂度。</li></ul><p><strong>缺点</strong></p><ul><li><strong>实现复杂</strong>：需要安装、配置和维护 Canal 服务。</li><li><strong>存在延迟</strong>：虽然 Canal 能够实时地同步数据，但仍然存在一定的延迟。</li><li><strong>需要考虑 Canal 的高可用</strong>：为了保证 Canal 服务的可用性，需要考虑 Canal 的高可用方案。</li><li><strong>需要监控Canal</strong>：需要对 Canal 服务进行监控，及时发现和解决问题</li></ul><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNptlFtPGkEUx7_KZhLf0HJV4aGJAt7x3jTpwsO2bJWUi0FoaoEEjQotFNYGBaGitqI0raKpVQRaPkx3BnjyK3R2ZlHauA-bmTm__zlnzpmZAHjhsfPAABa83NIiM2-yuhn8DbCwFoYnMRvT3f2YGWQtK3MzE9KSUHrucDs9CzbKDRK7MdA4PBPre9SEDmqwlhTLldmpp6h4iMchChslOIgypSBjYo2cm3NiM4rtE-fMnJN7zctuTcStmUJQ2KKEhVv28V6Y3Gr-vG7W8yhRaJau0cWaLDIT0RDbCWMGpa7-wYYINvwfVmyFV-X00wVYTzequyS4LBomohE5a-K0k5apEUKNUqp58gXlhQeoUUKNBWAyg3KXjYsqzMdwUcRqWLyJ3tb25WrR_xip2ejknHl2_tGTadPAvDnIjLPwfJPKoZBoZNfR9jn6cIanaOccRs9nebtj2dbpwGSeMEvKCRZGD1q7R4QQy6ewdAMrqTsPWENV4yRHCysZU8VGMQYrSbGaILJmqQqTO3cCCZ-geFttIdPJQDsK-vSO4lBI329w8v44TLHNegrm8pTCtadxbZ0gFI6DzDSLsyCdeyCLaRJ2RiqOHG5zF24UOqsxQ5CpdqJdXQz6UWxF3t_Wsuj0COZ-w4vtxlFFrGzC4zXx1zaMfsV50CbCj3Ha_r0CPusovkryEMu0KuJNrJW-lDeQXRfL4WbkEoVP_oTX7mK1wtlmPdLIbUHhOxFjUPadzMD4zm0tDm-upN5uXEEhjk4L7WbiIkrGJD4lBVLNKEoKrW8ZufH7-CZ8xouNRATHAwp8mx12YPB5_bwCuHivi5OmICBlYgW-Rd7FW4EBD-2c95UVWN0hrFni3M88Hldb5vX4FxaB4SXnXMYz_5Kd8_EmB4ffiXuEd9t5r9Hjd_uAQU88AEMAvAEGtV7To9MqlVqNSq_S63qVWgVYAYZulU7bo9Wp-vt0GqWmV93f1x9SgLckqqpH3avHSzq1tq9fqe7TYAneus_jtdAXijxUob-wZiEi"><img src="https://i-blog.csdnimg.cn/img_convert/cf3fd99e6604f3c14e07bc42461a959d.jpeg"></a></p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这是后端面试常问的问题，建议各位结合自己的项目进行回答，面试官问你的优化方法也可以有更多的思路。如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>后台缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>后台缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解单例模式</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这是设计模式专栏的第一篇文章，在这个专栏里面会讲到我们在开发中经常使用的设计模式，我会用心将它们解析，然后讲给你们听，如果感兴趣可以持续关注这个专栏❤️</p><p>这次我们要讲的是单例模式，这个在大厂面试中十分常见，有的面试官会让你<strong>手撕一个单例模式</strong>。抛去面试不谈，单例模式也是我们开发中常用的软件设计思想，许多框架的底层设计都是运用到这个设计思路，所以掌握好单例模式十分有必要</p><h1 id="什么是单例模式🤓"><a href="#什么是单例模式🤓" class="headerlink" title="什么是单例模式🤓"></a>什么是单例模式🤓</h1><p>单例模式（Singleton Pattern）是一种<strong>创建型设计模式</strong>，它确保<strong>一个类只有一个实例</strong>，并提供一个全局访问点来访问这个实例。</p><p>使用单例模式的场景有哪些呢？</p><ul><li>数据库连接池</li><li>日志记录器（Logger）</li><li>配置管理器</li><li>线程池</li><li>缓存服务</li></ul><p>这些对象只需要一个实例，避免重复创建造成资源浪费或状态不一致。</p><h1 id="单例模式的特点🥱"><a href="#单例模式的特点🥱" class="headerlink" title="单例模式的特点🥱"></a>单例模式的特点🥱</h1><ol><li><strong>私有构造函数</strong>：防止外部通过 <code>new</code> 创建实例。</li><li><strong>静态私有实例</strong>：类内部维护唯一的实例。</li><li><strong>公开的静态方法</strong>：用于返回唯一实例。</li></ol><p>单例模式创建分为饿汉式和懒汉式，接下来让我们一一解析</p><h1 id="饿汉式😈"><a href="#饿汉式😈" class="headerlink" title="饿汉式😈"></a>饿汉式😈</h1><p>为什么叫饿汉式呢？因为<strong>类加载就会导致该单实例对象被创建。</strong></p><p>那类加载又是什么呢？</p><p>在 Java 中，<strong>类加载</strong> 是指将 <code>.class</code> 文件（字节码文件）加载到 JVM（Java 虚拟机）中，并为其创建一个 <code>java.lang.Class</code> 对象的过程。这个过程是由 <strong>类加载器（ClassLoader）</strong> 完成的。</p><p>但是JVM不会在一开始就加载所有的类，而是在运行时按需加载，也就是说当某个类第一次被主动使用时才会触发类加载。例如：</p><ul><li>创建类的实例（<code>new</code>）</li><li>访问类的静态变量或调用静态方法</li><li>使用子类时会先加载父类</li><li>启动类（main 方法所在的类）</li></ul><p>还有一些被动引用的情况不会触发类加载，比如访问静态常量（编译期确定的 final static 常量），就不会触发类初始化。</p><p>下面讲讲饿汉式怎么创建单例：</p><h2 id="方法一：静态成员变量方式获取对象"><a href="#方法一：静态成员变量方式获取对象" class="headerlink" title="方法一：静态成员变量方式获取对象"></a>方法一：静态成员变量方式获取对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">//1. 私有无参构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//2. 创建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-comment">//3. 向外提供公共方法，可以获取单例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：静态代码块创建"><a href="#方法二：静态代码块创建" class="headerlink" title="方法二：静态代码块创建"></a>方法二：静态代码块创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">//1. 私有无参构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//2. 创建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-comment">//3. 静态代码块进行赋值</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">//4. 向外提供公共方法，可以获取单例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法三：枚举"><a href="#方法三：枚举" class="headerlink" title="方法三：枚举"></a>方法三：枚举</h2><p>枚举类型是线程安全的，并且只会装载一次。枚举是单例实现中唯一一种不会被破坏的单例实现模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="懒汉式🥱"><a href="#懒汉式🥱" class="headerlink" title="懒汉式🥱"></a>懒汉式🥱</h1><p>懒汉式，顾名思义就是，意思就是需要创建的时候再创建。类加载并不会导致该单实例对象创建，而是首次使用该对象时才会创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-comment">//1. 私有无参构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//2. 创建对象,使用volatile关键字防止指令重排序与保证变量可见性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br>    <br>    <span class="hljs-comment">//3. 向外提供公共方法，可以获取单例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//synchronized关键字修饰代码块保证只有一个线程可以创建单例对象</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这就是单例模式的解析，我们下次再见。</p><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解责任链模式</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这是设计模式专栏的第二篇文章，在这个专栏里面会讲到我们在开发中经常使用的设计模式，我会用心将它们解析，然后讲给你们听，如果感兴趣可以持续关注这个专栏❤️</p><p>这次我们要讲的是责任链模式，这是在实际的开发中非常常用的软件设计模式，为什么呢？又得讲到那个非常经典的例子了，你是一个程序员，今天临时起意想要暂时远离一下这种枯燥生活，去旅游或者休息，于是你在OA系统提起了七天的假期申请，需要流程审批。首先你的组长会看到这个审批，但是他没有权限审批七天的假期，又到你的Leader审批，但是他也同样没有这么大的权限，这个审批一直流转，终于流到了有能力审批七天假期的部门大佬….</p><p>这种像一个链子一样的，允许多个对象处理请求，请求会沿着建造好的链子前进，一直达到有能力处理的节点，这种就是责任链模式。</p><h1 id="责任链模式的定义😯"><a href="#责任链模式的定义😯" class="headerlink" title="责任链模式的定义😯"></a>责任链模式的定义😯</h1><p>上面说了这么多，那么责任链模式定义到底是什么呢？</p><p>责任链模式（Chain of Responsibility Pattern）是一种<strong>行为型设计模式</strong>，它允许多个对象有机会处理请求，从而避免请求的发送者和接收者之间的耦合。请求沿着一条链传递，直到有一个对象处理它为止。 </p><h2 id="责任链模式的核心思想"><a href="#责任链模式的核心思想" class="headerlink" title="责任链模式的核心思想"></a>责任链模式的核心思想</h2><ul><li><strong>将多个处理器连接成一条链</strong>。</li><li>请求从链的一端发起，沿着链传递，每个节点都有机会处理请求或将其传递给下一个节点。</li><li>如果当前节点不能处理该请求，则将请求转发给下一个节点。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><strong>请求的处理有多个步骤或条件</strong>，例如审批流程、权限控制等。</li><li><strong>请求的处理者不确定是谁</strong>，希望动态指定。</li><li><strong>解耦请求发送者和处理者</strong>，使系统更灵活、可扩展。</li></ol><h2 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h2><ul><li><strong>Handler（抽象处理者）</strong> ：定义处理请求的接口，通常包含一个指向下一个处理者的引用。</li><li><strong>ConcreteHandler（具体处理者）</strong> ：实现处理逻辑。可以决定是否处理请求或将请求传给下一个处理者。</li><li><strong>Client（客户端）</strong> ：创建处理链并提交请求。</li></ul><h1 id="责任链模式的具体使用😎"><a href="#责任链模式的具体使用😎" class="headerlink" title="责任链模式的具体使用😎"></a>责任链模式的具体使用😎</h1><p>上面的定义太枯燥了，直接来看怎么使用责任链模式吧，这里笔者选取了自己最熟悉也是觉得最好用的实现方式来给大家看看，如果有佬觉得还有更好的实现方式欢迎在评论区留言或者私信交流🤓</p><p>ps：笔者只展示最主要的部分，请大家集中注意力关注主要部分</p><h2 id="责任链装载接口"><a href="#责任链装载接口" class="headerlink" title="责任链装载接口"></a>责任链装载接口</h2><p>这里是责任链的装载接口，appendNext负责添加下一个责任链节点，next()负责返回责任链中的下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILogicChainArmory</span> &#123;<br><br>    ILogicChain <span class="hljs-title function_">appendNext</span><span class="hljs-params">(ILogicChain next)</span>;<br><br>    ILogicChain <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="责任链接口"><a href="#责任链接口" class="headerlink" title="责任链接口"></a>责任链接口</h2><p>这个责任链接口，就是对应的节点类型，logic方法就是每个具体节点都要实现的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILogicChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ILogicChainArmory</span>&#123;<br>    <br>    DefaultChainFactory.StrategyAwardVO <span class="hljs-title function_">logic</span><span class="hljs-params">(String userId, Long strategyId)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="责任链抽象类"><a href="#责任链抽象类" class="headerlink" title="责任链抽象类"></a>责任链抽象类</h2><p>由于ILogicChain extends ILogicChainArmory，实现子接口的类也必须提供这些方法的具体实现。</p><p>但是因为AbstractLogicChain是抽象类，所以实现任意一部分就行了（甚至可以不实现），这里我们实现责任链的装载方法，让具体责任链实现节点类只需要负责实现具体逻辑logic就行，不需要关注其他多余实现（设计模式的各司其职）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractLogicChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILogicChain</span>&#123;<br><br><br>    <span class="hljs-keyword">private</span> ILogicChain next;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ILogicChain <span class="hljs-title function_">appendNext</span><span class="hljs-params">(ILogicChain next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ILogicChain <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="责任链具体节点（黑名单节点示例）"><a href="#责任链具体节点（黑名单节点示例）" class="headerlink" title="责任链具体节点（黑名单节点示例）"></a>责任链具体节点（黑名单节点示例）</h2><p>这里是一个责任链的具体节点，继承了上面的抽象类，实现具体逻辑即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component(&quot;rule_blacklist&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BackListLogicChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractLogicChain</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IStrategyRepository repository;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DefaultChainFactory.StrategyAwardVO <span class="hljs-title function_">logic</span><span class="hljs-params">(String userId, Long strategyId)</span> &#123;<br>        <span class="hljs-comment">//获得对应策略，黑名单的用户配置和奖品配置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ruleValue</span> <span class="hljs-operator">=</span> repository.queryStrategyRuleValue(strategyId, ruleModel());<br><br><br>        String[] splitRuleValue = ruleValue.split(Constants.COLON);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">awardId</span> <span class="hljs-operator">=</span> Integer.parseInt(splitRuleValue[<span class="hljs-number">0</span>]);<br><br>        String[] userBlackIds = splitRuleValue[<span class="hljs-number">1</span>].split(Constants.SPLIT);<br><br>        <span class="hljs-comment">// 黑名单判断</span><br>        <span class="hljs-keyword">for</span> (String userBlackId : userBlackIds) &#123;<br>            <span class="hljs-keyword">if</span> (userId.equals(userBlackId)) &#123;<br>                <span class="hljs-keyword">return</span> DefaultChainFactory.StrategyAwardVO.builder()<br>                        .awardId(awardId)<br>                        .logicModel(ruleModel())<br>                        .build();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 过滤其他责任链</span><br>        <span class="hljs-keyword">return</span> next().logic(userId, strategyId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="默认节点"><a href="#默认节点" class="headerlink" title="默认节点"></a>默认节点</h2><p>这是一个默认的责任链节点，代表请求最终一定可以处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component(&quot;default&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultLogicChain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractLogicChain</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">protected</span> IStrategyDispatch strategyDispatch;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DefaultChainFactory.StrategyAwardVO <span class="hljs-title function_">logic</span><span class="hljs-params">(String userId, Long strategyId)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">awardId</span> <span class="hljs-operator">=</span> strategyDispatch.getRandomAwardId(strategyId);<br>        <br>        <span class="hljs-keyword">return</span> DefaultChainFactory.StrategyAwardVO.builder()<br>                .awardId(awardId)<br>                .logicModel(ruleModel())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="责任链工厂"><a href="#责任链工厂" class="headerlink" title="责任链工厂"></a>责任链工厂</h2><p>这里是责任链工厂，负责装载责任链。通过Spring的依赖注入，我们可以很方便的得到所有实现了ILogicChain的具体实现类，通过一个map类型来承载（只有打上注解<code>@Component</code>的具体节点实现类才可以被Spring的bean容器管理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultChainFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ILogicChain&gt; logicChainGroup;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IStrategyRepository repository;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultChainFactory</span><span class="hljs-params">(Map&lt;String, ILogicChain&gt; logicChainGroup, IStrategyRepository repository)</span> &#123;<br>        <span class="hljs-built_in">this</span>.logicChainGroup = logicChainGroup;<br>        <span class="hljs-built_in">this</span>.repository = repository;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ILogicChain <span class="hljs-title function_">openLogicChain</span><span class="hljs-params">(Long strategyId)</span> &#123;<br>        <span class="hljs-type">StrategyEntity</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> repository.queryStrategyEntityByStrategyId(strategyId);<br>        <span class="hljs-comment">//获得该策略对应的ruleModels</span><br>        String[] ruleModels = strategy.ruleModels();<br><br>        <span class="hljs-comment">// 如果未配置策略规则，则只装填一个默认责任链</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == ruleModels || <span class="hljs-number">0</span> == ruleModels.length) <span class="hljs-keyword">return</span> logicChainGroup.get(<span class="hljs-string">&quot;default&quot;</span>);<br><br>        <span class="hljs-comment">// 按照配置顺序装填用户配置的责任链</span><br>        <span class="hljs-type">ILogicChain</span> <span class="hljs-variable">logicChain</span> <span class="hljs-operator">=</span> logicChainGroup.get(ruleModels[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">ILogicChain</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> logicChain;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; ruleModels.length; i++) &#123;<br>            <span class="hljs-type">ILogicChain</span> <span class="hljs-variable">nextChain</span> <span class="hljs-operator">=</span> logicChainGroup.get(ruleModels[i]);<br>            current = current.appendNext(nextChain);<br>        &#125;<br><br>        <span class="hljs-comment">// 责任链的最后装填默认责任链</span><br>        current.appendNext(logicChainGroup.get(<span class="hljs-string">&quot;default&quot;</span>));<br><br>        <span class="hljs-keyword">return</span> logicChain;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="测试使用😈"><a href="#测试使用😈" class="headerlink" title="测试使用😈"></a>测试使用😈</h1><p>通过openLogicChain我们就可以获得责任链的头节点，请求放进去就可以在里面流转，最终一定会被处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_LogicChain_rule_blacklist</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ILogicChain</span> <span class="hljs-variable">logicChain</span> <span class="hljs-operator">=</span> defaultChainFactory.openLogicChain(<span class="hljs-number">100001L</span>);<br>    DefaultChainFactory.<span class="hljs-type">StrategyAwardVO</span> <span class="hljs-variable">awardId</span> <span class="hljs-operator">=</span> logicChain.logic(<span class="hljs-string">&quot;user001&quot;</span>, <span class="hljs-number">100001L</span>);<br>    log.info(<span class="hljs-string">&quot;测试结果：&#123;&#125;&quot;</span>, awardId);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这就是责任链模式的解析，我们下次再见。</p><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一站式了解CDN</title>
    <link href="/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3CDN/"/>
    <url>/2025/06/22/%E4%B8%80%E7%AB%99%E5%BC%8F%E4%BA%86%E8%A7%A3CDN/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们日常使用手机电脑都要访问静态资源，如图片、CSS文件和JavaScript文件等，如果每一个静态资源的请求都需要到达服务器，那势必会加重服务器的压力，那有什么方法解决呢？有的，兄弟，那就是今天要讲的CDN。</p><h1 id="CDN是什么？😯"><a href="#CDN是什么？😯" class="headerlink" title="CDN是什么？😯"></a>CDN是什么？😯</h1><p>CDN，全称Content Delivery Network，即内容分发网络。它是一种通过互联网协议（Internet Protocol）将网站内容分发至全球多个地理位置不同的服务器上的方法。其主要目的是提高用户访问网站的速度和性能，同时提高内容的可用性和可靠性。</p><ol><li><strong>节点（PoP - Point of Presence）</strong> ：指的是CDN提供商在全球各地设立的数据中心或服务器位置。每个节点都存储有源站的部分或全部内容副本。</li><li><strong>缓存（Caching）</strong> ：为了加速内容传递速度，CDN会将用户的请求指向最近的节点，并从该节点提供内容，而不是每次都从源站获取。这需要在各个节点上对静态资源进行缓存。</li><li><strong>负载均衡（Load Balancing）</strong> ：通过智能算法将流量分配到不同的节点上，确保没有单个服务器过载，同时也保证了服务的高可用性。</li><li><strong>回源（Origin Pull）</strong> ：当CDN节点没有找到请求的内容时，会向源站发起请求，将内容拉取到本地并提供给用户，同时缓存一份以备后续使用。</li><li><strong>边缘计算（Edge Computing）</strong> ：随着技术的发展，CDN不仅限于内容分发，还涉及到在靠近用户的网络边缘执行计算任务，以减少延迟、提高效率。</li><li><strong>安全性</strong>：CDN也能提供额外的安全层，比如DDoS攻击防护、SSL加密等，保护源站免受恶意攻击。</li></ol><p>通过使用CDN，可以显著改善用户体验，特别是对于那些拥有全球用户基础的网站和服务来说，能够极大地减少加载时间，提升整体性能</p><h1 id="使用CDN的好处是什么🥱"><a href="#使用CDN的好处是什么🥱" class="headerlink" title="使用CDN的好处是什么🥱"></a>使用CDN的好处是什么🥱</h1><p>使用CDN主要是为了通过将静态资源如图片、CSS文件和JavaScript文件等分布存储在全球各地的服务器上，CDN使得这些资源更接近最终用户，从而减少服务器的压力。</p><p>还有以下的好处：</p><ol><li><strong>减少延迟</strong>：由于静态资源从地理位置上更接近用户的服务器获取，数据传输的距离缩短，因此可以显著减少请求响应时间，提高页面加载速度。</li><li><strong>降低源服务器负载</strong>：当用户请求静态资源时，可以直接从最近的CDN节点获取，而不是每次都访问源服务器。这减少了直接对源服务器的请求数量，从而减轻了服务器的压力，并降低了带宽成本。</li><li><strong>提高可用性和冗余性</strong>：CDN通常由分布在不同地理位置的多个服务器组成。如果某个节点发生故障，其他节点仍然可以提供服务，确保了高可用性和稳定性。</li><li><strong>增强安全性</strong>：许多CDN服务还提供额外的安全功能，比如DDoS攻击防护、SSL&#x2F;TLS加密等，有助于保护网站免受恶意攻击，同时保护敏感数据的安全。</li><li><strong>改善用户体验</strong>：更快的内容加载速度意味着更好的用户体验，这对于保持访客的满意度和参与度至关重要。</li></ol><h1 id="CDN-Nginx-😵"><a href="#CDN-Nginx-😵" class="headerlink" title="CDN &amp; Nginx 😵"></a>CDN &amp; Nginx 😵</h1><p>那么我们说了CDN有直接给用户派发静态资源的作用，那么Nginx也有直接返回静态资源给用户的作用呀，那么两者之间到底有什么区别呢？</p><p>Nginx侧重为服务器提供静态资源的缓存，当请求来则可以直接返回，而CDN则侧重全球范围提供静态资源，减少Nginx和源站的压力</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul><li><strong>静态资源服务</strong>：Nginx可以高效地直接提供静态资源（如图片、CSS、JS文件等），它可以从本地文件系统中读取这些资源，并迅速响应客户端请求。这使得Nginx非常适合用作前端Web服务器。</li><li><strong>缓存功能</strong>：虽然Nginx本身主要不是作为缓存解决方案设计的，但它确实支持配置缓存机制来存储后端服务器的响应结果（包括动态内容）。这意味着它可以减少对后端服务器的请求次数，提高响应速度并减轻后端服务器的负担。</li><li><strong>灵活性和控制</strong>：Nginx提供了强大的配置选项，允许你精细地控制如何处理请求、管理会话、设置响应头等，适用于需要高度定制化需求的场景。</li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><ul><li><strong>全球分发</strong>：CDN的主要作用是将静态资源分布到全球各地的多个节点上，这样无论用户位于世界何处，都可以从地理位置最近的节点快速获取所需的内容。这种方式不仅能减少延迟，还能显著提升用户体验。</li><li><strong>减压源站</strong>：通过在边缘节点缓存源站的内容，CDN减少了直接访问源站的需求，从而降低了源站服务器的压力以及带宽消耗。当一个用户的请求到达CDN节点时，如果该资源已被缓存，则直接由CDN节点返回给用户；如果没有被缓存，则CDN会回源站拉取资源并缓存以供后续使用。</li><li><strong>增强的可靠性和安全性</strong>：除了加速内容传输外，CDN还提供了改进的可靠性和额外的安全层，比如防止DDoS攻击的能力。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>Nginx</strong> 更侧重于作为高效的Web服务器或反向代理服务器，可以直接处理静态资源请求，也可以配置缓存策略减轻后端服务器的压力。</li><li><strong>CDN</strong> 则专注于在全球范围内优化静态资源的分发，通过利用其广泛的节点网络减少延迟，同时也能有效分散源站的负载压力。</li></ul><p>两者可以结合使用，例如，Nginx可以作为源站服务器处理动态请求和部分静态资源，而CDN则用来加速静态资源的全球分发和服务，以此达到最佳的性能和可靠性</p><h1 id="静态资源是如何缓存到CDN节点的？😪"><a href="#静态资源是如何缓存到CDN节点的？😪" class="headerlink" title="静态资源是如何缓存到CDN节点的？😪"></a>静态资源是如何缓存到CDN节点的？😪</h1><p>一般需要相关人员主动将静态资源先预热到CDN节点，这样就不会导致用户请求到服务器中取，可以减少服务器压力。</p><p>如果访问CDN节点，发现所需的静态资源不在，则需要访问对应的服务器获取资源，顺便再给CDN节点缓存上对应的静态资源，这就是回源</p><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNp1kstKw0AUhl8lnHUsuTbJLARt1JWuXJm4CGZ6AZOUmIBauykutFAvtIhFUVwIoogIar37Mk6Sx3CS1EsXzmrO5fv_w8xpwJJnY0BQ8a16lZnXTZehZ8KIexfR1iC5GUS3reR-M3reW2TGxsaZSaOkzyXtVtx6ik7Po-33-LVLrg8Xc24y7dkg-2-fj9d5YYMpGfHRXbRznnz0yNFJrhW_9HODES46vhxF9V8zilIu2RmQ3YPhPDmqZ2NNGanqVT867pD2GelfkG6HPPfI08Nf2yEylSHTv-K530jPdNYzY_w_NbD00Wo2oMAPMQsO9h0rDaGRVk0IqtjBJiB6tXHZCpcDE0y3SbG65S54nvNN-l5YqQIqW8srNArrthVgvWbRH3F-sj52beyXvNANAPFipgGoAauAZKkg8KKoaLzKFQVN5WUW1gBJcoGTNVHiZFURVEHmmyysZ65cQVU0TeYkTuKLCq_IVA7btcDzZ_NdyFai-QWyQ-rg"><img src="https://mermaid.ink/img/pako:eNp1kstKw0AUhl8lnHUsuTbJLARt1JWuXJm4CGZ6AZOUmIBauykutFAvtIhFUVwIoogIar37Mk6Sx3CS1EsXzmrO5fv_w8xpwJJnY0BQ8a16lZnXTZehZ8KIexfR1iC5GUS3reR-M3reW2TGxsaZSaOkzyXtVtx6ik7Po-33-LVLrg8Xc24y7dkg-2-fj9d5YYMpGfHRXbRznnz0yNFJrhW_9HODES46vhxF9V8zilIu2RmQ3YPhPDmqZ2NNGanqVT867pD2GelfkG6HPPfI08Nf2yEylSHTv-K530jPdNYzY_w_NbD00Wo2oMAPMQsO9h0rDaGRVk0IqtjBJiB6tXHZCpcDE0y3SbG65S54nvNN-l5YqQIqW8srNArrthVgvWbRH3F-sj52beyXvNANAPFipgGoAauAZKkg8KKoaLzKFQVN5WUW1gBJcoGTNVHiZFURVEHmmyysZ65cQVU0TeYkTuKLCq_IVA7btcDzZ_NdyFai-QWyQ-rg?type=png"></a></p><p>CDN缓存不是永久有效的，可以采用以下方式来进行更新或者失效缓存：</p><ul><li><strong>自然过期</strong>：根据 <code>Cache-Control</code> 或 <code>Expires</code> 时间自动失效</li><li><strong>主动刷新</strong>：手动调用 CDN 接口清除特定 URL 或目录的缓存</li><li><strong>版本控制更新</strong>：修改文件名或添加版本号（如 <code>style-v2.css</code>），避免旧缓存影响</li></ul><h1 id="CDN多级缓存架构🤓"><a href="#CDN多级缓存架构🤓" class="headerlink" title="CDN多级缓存架构🤓"></a>CDN多级缓存架构🤓</h1><p>一些大型 CDN 还有 <strong>多级缓存架构</strong>：</p><ul><li><strong>边缘节点（Edge Node）</strong> ：最靠近用户的节点，缓存热门资源</li><li><strong>中间节点（Mid-Tier Node）</strong> ：区域中心节点，用于集中缓存非热门但常用资源</li><li><strong>源站（Origin Server）</strong> ：最终数据来源</li></ul><p>这样设计可以减少回源次数，提高整体效率</p><h1 id="如何寻找最合适的CDN节点😣"><a href="#如何寻找最合适的CDN节点😣" class="headerlink" title="如何寻找最合适的CDN节点😣"></a>如何寻找最合适的CDN节点😣</h1><p><strong>GSLB（全局负载均衡）</strong> 起了重要作用，用于智能地将用户请求导向到最优的 CDN 节点。</p><p><strong>GSLB 如何工作？</strong></p><ol><li><p><strong>DNS 查询解析</strong></p><ul><li>当用户尝试访问一个使用了 CDN 的网站时，首先会发起 DNS 查询来解析域名对应的 IP 地址。</li><li>这个查询会被导向到支持 GSLB 的 DNS 服务器。</li></ul></li><li><p><strong>基于策略的路由</strong></p><ul><li><strong>地理位置</strong>：GSLB 系统通常会根据发出请求的用户的地理位置来选择最近的 CDN 节点。这涉及到使用数据库或服务来确定用户的大概位置。</li><li><strong>网络性能</strong>：一些高级的 GSLB 实现还会考虑实时网络条件，如延迟、丢包率等，以选择提供最佳性能的节点。</li><li><strong>负载情况</strong>：GSLB 可以监控各个 CDN 节点的当前负载，并将流量分配给负载较低的节点，确保资源的有效利用和响应时间的优化。</li><li><strong>健康检查</strong>：持续监测各节点的可用性，自动避开故障或表现不佳的节点。</li></ul></li><li><p><strong>动态调整</strong></p><ul><li>基于上述因素，GSLB 系统能够动态调整其路由决策，即使在网络状况变化或者某些节点出现故障的情况下也能保证用户被引导至最佳的服务节点。</li></ul></li></ol><p>然后GSIB将最合适的CDN节点IP地址发回给浏览器，让他去访问。</p><h1 id="总结❤️"><a href="#总结❤️" class="headerlink" title="总结❤️"></a>总结❤️</h1><p>这就是相关CDN的解析</p><p>如果你看了这篇文章有收获可以点赞+关注+收藏🤩，这是对笔者更新的最大鼓励！如果你有更多方案或者文章中有错漏之处，请在评论区提出帮助笔者勘误，祝你拿到更好的offer！</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
